#+Title: Aner's Emacs Configuration

#+property: header-args :results silent
#+options: toc:2
#+latex_class: article

* Base Configuration

** Package installation with straight and use-package

Installation of all required packages.

Straight initialization found [[https://www.github.com/raxod502/straight.el][here]]

#+begin_src emacs-lisp
(setq straight-disable-native-compile t)

(setq comp-deferred-compilation-deny-list nil)

(defvar bootstrap-version)
(let ((bootstrap-file
    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
(with-current-buffer
    (url-retrieve-synchronously
        "https://raw.githubusercontent.com/raxod502/straight.el/master/install.el"
        'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

(setq vc-follow-symlinks t)
#+end_src

Installing use-package
Installation of usepackage taken from [[https://github.com/KaratasFurkan/.emacs.d/][KaratasFurkan's generously shared emacs config]].

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+end_src

** Backup files

Taken from [[https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][this post on StackOverflow]]

Backups are moved to a =.cache= directory in order to keep them out of local dirs.

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . "~/.cache/emacs-backups/"))
      auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))
      backup-by-copying t
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)
#+end_src

** Garbage collection

Setting garbage collection to 100M to make it stop freaking out every time I scroll through text.

#+begin_src emacs-lisp

(setq gc-cons-threshold 100000000)

#+end_src

** CL

CL is a base library that has a bunch of useful stuff, primarily for lists.
We are using the built-in version, no need to pull from anywhere.
This just makes sure the code is loaded early on for later use.

#+begin_src emacs-lisp
(use-package cl-lib
  :straight (:type built-in))
#+end_src

** Services

This section defines functions and variables primarily used when Emacs is used as the OS
The aim of this section is to provide functions to run programs that run in the background.
This way we can run psuedo-services that run while Emacs runs.

The variable =anerenv/service-table= is a hash table mapping between name to process.

This way we can keep one instance of every process we wish to run as a psuedo-service.

#+begin_src emacs-lisp
(defvar anerenv/service-table (make-hash-table)
  "Table to store psuedo-service processes in")
#+end_src

=anerenv-kill/service= kills the process and deletes the entry. We use a sleep function
inside because some processes cannot run concurrently. Killing and immediately starting
these processes causes some problems with the process lock.

#+begin_src emacs-lisp
(defun anerenv/kill-service (servicename) "Kills a service from the table."
    (progn
        (let ((proc (gethash servicename anerenv/service-table)))
            (if proc (progn (delete-process proc) (sleep-for 0.1))))
        (remhash servicename anerenv/service-table)))
#+end_src

=anerenv/run-service= makes sure an entry in the service table exists. If it does,
and it's a process, kill it. Then run a new process.

#+begin_src emacs-lisp
(defun anerenv/run-service (servicename command args &optional wbuff)
    (progn
        (anerenv/kill-service servicename)
        (let ((servicestr (symbol-name servicename)))
            (let ((buffname (if wbuff
                                (concat "*service-" servicestr "*")
                                nil)))
                (let ((arglist
                    (append (list 'start-process servicestr buffname command)
                                args)))
                    (puthash servicename (apply arglist)
                        anerenv/service-table))))
        (set-process-query-on-exit-flag
            (gethash servicename anerenv/service-table)
            nil)))
#+end_src

** Timers

Much like services, we would like to be able to run timer functions periodically

The variable =anerenv/timer-table= is a hash table mapping between name to a timer.

This way we can keep one instance of every timer we wish to run.

#+begin_src emacs-lisp
(defvar anerenv/timer-table (make-hash-table)
  "Table to store timers in")
#+end_src

=anerenv/kill-timer= kills the timer and deletes the entry. We use a sleep function
inside because some processes cannot run concurrently. Killing and immediately starting
these functions can sometimes cause hiccups, as with services.

#+begin_src emacs-lisp
(defun anerenv/kill-timer (timername) "Kills a timer from the table."
    (progn
        (let ((timer (gethash timername anerenv/timer-table)))
            (if timer (progn (cancel-timer timer) (sleep-for 0.1))))
        (remhash timername anerenv/timer-table)))
#+end_src

=anerenv/run-timer= makes sure an entry in the timer table exists. If it does,
and it's a timer, kill it. Then run a new timer.

#+begin_src emacs-lisp
(defun anerenv/run-timer (timername func period)
    (progn
        (anerenv/kill-timer timername)
        (puthash timername (run-with-timer 0 period func)
                 anerenv/timer-table)))
#+end_src

Also add ability to run one time task.

#+begin_src emacs-lisp
(defun anerenv/run-one-time-task (timername func delay)
    (progn
        (anerenv/kill-timer timername)
        (puthash timername (run-with-timer delay nil func)
                 anerenv/timer-table)))
#+end_src

** Keymap setup

In this section global keybindings are defined using a global minor mode.

First, utility functions that will be bound are defined.

The first, =anerenv/set-window-width= is a helper function that resizes a window. Used because I wanted a function
that resizes a window to 85 cols easily.

The second, =anerenv/open-conf-file=,  opens the configuration file.

#+begin_src emacs-lisp
(defun anerenv/set-window-width (n)
    (adjust-window-trailing-edge (selected-window) ( - n (window-width)) t))

(defun anerenv/open-conf-file ()
    (interactive)
    (find-file (concat user-emacs-directory "config.org")))
#+end_src

Now let's define keybindings. To start, we'd like =M-o= to be available to us, so let's unbind it.

#+begin_src emacs-lisp
;Unbind face menu map
(define-key global-map (kbd "M-o") nil)
#+end_src

This creates an "open keymap", a bunch of keybindings we'll use to open basic applications and files.
This will be mapped to =M-o=, and things will be opened form this sub-menu.
We'll start it with a binding to open the conf file with =M-o o= (MOO!)

Setting of keybindings based on [[https://stackoverflow.com/questions/49853494/the-best-way-to-set-a-key-to-do-nothing][this]]

#+begin_src emacs-lisp
;We'll define a basic keymap and already load window-manip funcs
(defvar anerenv-global-minor-mode-open-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "o") 'anerenv/open-conf-file)
    map)
  "global keymap for opening stuff on anerenv")
#+end_src

At this stage a minor-mode-map is defined with keybindings, and an accompanying minor-mode is added.

#+begin_src emacs-lisp
(defvar anerenv-global-minor-mode-map
  (let ((map (make-sparse-keymap)))

    ;Window movement and manipulation
    (define-key map (kbd "M-h") 'windmove-left)
    (define-key map (kbd "M-l") 'windmove-right)
    (define-key map (kbd "M-k") 'windmove-up)
    (define-key map (kbd "M-j") 'windmove-down)

    (define-key map (kbd "M-<left>") 'windmove-left)
    (define-key map (kbd "M-<right>") 'windmove-right)
    (define-key map (kbd "M-<up>") 'windmove-up)
    (define-key map (kbd "M-<down>") 'windmove-down)
    (define-key map (kbd "M-d M-d") 'delete-window)
    (define-key map (kbd "M-d D") 'kill-buffer-and-window)
    (define-key map (kbd "M-\\") 'split-window-horizontally)
    (define-key map (kbd "M-\-") 'split-window-vertically)
    (define-key map (kbd "M-d R") (lambda () (interactive)
                    (set-window-width 85)))
    (define-key map (kbd "M-o") anerenv-global-minor-mode-open-map)
    map)
  "anerenv-global-minor-mode keymap.")

(define-minor-mode anerenv-global-minor-mode
  "A minor mode for anerenv global keymaps."
  :init-value t
  :lighter "anerenv")

(anerenv-global-minor-mode 1)
#+end_src

This keymap will be referenced many times during this document at relevant points.

Keymaps are included with relevant sections.

** EVIL mode

Using evil mode.

This section includes unbinding =C-w= (I honestly forget why).

This section binds keys for changing window size. Done here because can only do after evil loads.

Unbinding C-w taken from https://stackoverflow.com/questions/24988406/unbinding-evils-c-w-mappings

#+begin_src emacs-lisp
(setq evil-want-keybinding nil)

(use-package evil
  :init
  (setq evil-want-C-i-jump nil)
  :config
  (require 'evil )
  (evil-mode 1)

  :bind
  (:map anerenv-global-minor-mode-map
        ("M-w h" . evil-window-decreace-width)
        ("M-w l" . evil-window-increase-width)
        ("M-w k" . evil-window-decrease-height)
        ("M-w j" . evil-window-increase-height))
)
#+end_src

Loading evil collection. Functions from this package will be referenced many times later in the configuration.

#+begin_src emacs-lisp
(use-package evil-collection
  :config
  (setq evil-collection-setup-minibuffer t)
)
#+end_src

Setting theme colors

#+begin_src emacs-lisp
(defvar anerenv/evil-color-normal "LightGoldenrod1")
(defvar anerenv/evil-color-emacs "LightBlue1")
(defvar anerenv/evil-color-insert "PaleGreen1")
(defvar anerenv/evil-color-replace "LightPink")
(defvar anerenv/evil-color-motion "LightCyan")
(defvar anerenv/evil-color-visual "LightGray")
(defvar anerenv/evil-color-operate "sandy brown")
#+end_src

** Undo tree

Loading =undo-tree= for undo/redo functionality with evil.

Redo taken from https://github.com/syl20bnr/spacemacs/issues/14036

#+begin_src emacs-lisp
(use-package undo-tree
  :after evil
  :config
    (evil-set-undo-system 'undo-tree)
    (setq undo-tree-history-directory-alist
        (list (cons "." (concat user-emacs-directory "undo-tree"))))
    (global-undo-tree-mode 1)
)
#+end_src

** IVY

Enabling IVY. Taken from [[https://github.com/abo-abo/swiper][their website]].

Using ivy, hydra, counsel.

#+begin_src emacs-lisp
(use-package ivy
  :custom
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    (ivy-count-format "(%d/%d) ")
  :config
    (ivy-mode 1)
)

(use-package ivy-hydra
  :after ivy)
(use-package ivy-avy
  :after ivy)
(use-package counsel
  :after ivy

  :bind
    (:map anerenv-global-minor-mode-map
        ("M-i" . counsel-imenu)
        ("M-b" . counsel-switch-buffer)
        ("C-x C-f" . counsel-find-file))
    (:map anerenv-global-minor-mode-open-map
        ("l" . counsel-linux-app))
)
#+end_src

Using swiper. Replacing evil search with swiper search.

#+begin_src emacs-lisp
(use-package swiper
    :after ivy evil
    :config
    (setq evil-search-module 'swiper-isearch)

    :bind
    (:map anerenv-global-minor-mode-map
        ("C-s" . swiper-isearch))
)
#+end_src

*** Keymaps

#+begin_src emacs-lisp
(evil-collection-ivy-setup)
#+end_src

** Projectile

Startup up projectile.

A config line here disables modeline display because I don't want my modeline to be cluttered.

Mapping modeline commands to =M-p= prefix. Also adding a shortcut to add project.

#+begin_src emacs-lisp
(use-package projectile
  :config
    (projectile-mode +1)
    (setq projectile-mode-line-function (lambda () ""))
  :bind
    (:map projectile-command-map
          ("a" . projectile-add-known-project)
    )
    (:map anerenv-global-minor-mode-map
          ("M-p" . projectile-command-map))
)
#+end_src

Ivy for projectile:
Parts taken from [[https://emacs.stackexchange.com/questions/40787/display-corresponding-key-binding-of-command-during-m-x-completion][this post]] and [[https://emacs.stackexchange.com/questions/38841/counsel-m-x-always-shows][this post]] from StackOverflow.

Helps with many functions to use counsel's/ivy's autocomplete with projectile.

#+begin_src emacs-lisp
(use-package counsel-projectile
  :config
    (counsel-projectile-mode +1)
    (setq projectile-completion-system 'ivy)
    ;Making counsel start with empty regex
    (when (commandp 'counsel-M-x)
        (global-set-key [remap execute-extended-command] 'counsel-M-x))
    (setcdr (assoc 'counsel-M-x ivy-initial-inputs-alist) "")
)
#+end_src

** Tramp

Ensuring tramp is loaded, and loading counsel-tramp for easy tramping.

#+begin_src emacs-lisp
(use-package tramp
  :straight (:type built-in))

(use-package counsel-tramp)
#+end_src

** YASnippet

Loading yasnippet. Useful for snippeting. Mode-specific snippets defined in relevant sections.

#+begin_src emacs-lisp
(use-package yasnippet
  :config
    (yas-global-mode 1)
)
#+end_src

** Flycheck

Flycheck is for syntax checking. Mode-specific configs in their relevant sections.

#+begin_src emacs-lisp
(use-package flycheck
  :config
    (global-flycheck-mode 1)
)
#+end_src

** Utility functions

Defining a function to copy filename.

#+begin_src emacs-lisp
(defun anerenv/copy-file-name () (interactive)
       (let ((fpath buffer-file-name))
         (if fpath (kill-new fpath) (message "No current file!"))))
#+end_src

** Notifications

#+begin_src emacs-lisp
(use-package notifications
  :straight (:type built-in))
#+end_src

* Text

** Text font

This section configures the base fonts. We select fonts if available (have configurations for good defaults in
Linux and Windows).

Also setting default fixed-pitch and variable-pitch fonts.

Setting font size to 10. The value to place is font-size * 10

Font size 12 for variable pitch.

The function =font-candidate= is from https://www.gnu.org/software/emacs/manual/html_mono/cl.html.

#+begin_src emacs-lisp
(defun anerenv/font-candidate (&rest fonts)
    "Return existing font which first match."
    (cl-find-if (lambda (f) (find-font (font-spec :name f))) fonts))

(let ((variable-font (anerenv/font-candidate
                      "Liberation Serif" "Microsoft Sans Serif")))
    (if variable-font
        (set-face-attribute 'variable-pitch nil :font variable-font)))

(let ((fixed-font (anerenv/font-candidate
                   "Iosevka" "LiberationMono" "Consolas")))
    (if fixed-font (progn
        (set-face-attribute 'default nil :font fixed-font)
        (set-face-attribute 'fixed-pitch nil :font fixed-font))))

(set-face-attribute 'default nil :height 100)
(set-face-attribute 'variable-pitch nil
    :height 130
    :weight 'normal
    :width 'normal)

(set-face-attribute 'fixed-pitch nil
    :height 100
    :weight 'normal
    :width 'normal)

(defun anerenv/default-variable-pitch ()
    (face-remap-add-relative 'default '(:inherit 'variable-pitch)))
#+end_src

** Line numbering

We want line numbering, but only in modes where it makes sense.

To do this, a custom minor-mode, =anerenv/global-linum-mode=, is created.
This mode selectively activates linum-mode if the mode is not one of a selected exempt modes.
These exempt modes are defined in =display-line-numbers-exempt-modes=.

Taken from [[https://www.emacswiki.org/emacs/LineNumbers][this wiki entry]].

#+begin_src emacs-lisp
(use-package display-line-numbers
    :init
        (defcustom anerenv/display-line-numbers-exempt-modes
            '(vterm-mode
              eshell-mode
              shell-mode
              term-mode
              ansi-term-mode
              magit-mode
              magit-diff-mode
              notmuch-hello
              pdf-view-mode)
            "Major modes on which to disable the linum mode, exempts them."
            :group 'display-line-numbers
            :type 'list
            :version "green")

        (define-global-minor-mode anerenv/global-linum-mode
            display-line-numbers-mode
            (lambda () (if (and
                (not (apply 'derived-mode-p
                            anerenv/display-line-numbers-exempt-modes))
                (not (minibufferp)))
            (display-line-numbers-mode))))

        (setq display-line-numbers-type 'visual
            display-line-numbers-grow-only 1
            display-line-numbers-width-start 1)

    :config
        (anerenv/global-linum-mode 1)
        (set-face-attribute 'line-number nil
            :family (face-attribute 'fixed-pitch :family))
)
#+end_src

** Line highlight

Highlighting line with cursor.

#+begin_src emacs-lisp
(global-hl-line-mode)
(set-face-attribute 'hl-line nil :background anerenv/evil-color-emacs)

(defface hl-line-normal
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-normal
                      :extend t)))
    "Highlight face for evil normal mode."
    :group 'hl-line)

(defface hl-line-insert
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-insert
                      :extend t)))
    "Highlight face for evil insert mode."
    :group 'hl-line)

(defface hl-line-emacs
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-emacs
                      :extend t)))
    "Highlight face for evil insert mode."
    :group 'hl-line)

(defface hl-line-replace
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-replace
                      :extend t)))
    "Highlight face for evil insert mode."
    :group 'hl-line)

(defface hl-line-motion
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-motion
                      :extend t)))
    "Highlight face for evil insert mode."
    :group 'hl-line)

(defface hl-line-visual
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-visual
                      :extend t)))
    "Highlight face for evil insert mode."
    :group 'hl-line)

(defface hl-line-operate
  (list (list t (list :inherit 'hl-line :background  anerenv/evil-color-operate
                      :extend t)))
    "Highlight face for evil insert mode."
    :group 'hl-line)

(defun anerenv/hl-line-evil/set-hl-state (state-face)
  "Refresh hl-line to be state-face"
  (progn
    (global-hl-line-unhighlight)
    (setq-local hl-line-face state-face)
    (global-hl-line-highlight)))
#+end_src

#+begin_src emacs-lisp
(add-hook 'evil-insert-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-insert)))
(add-hook 'evil-normal-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-normal)))
(add-hook 'evil-emacs-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-emacs)))
(add-hook 'evil-replace-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-replace)))
(add-hook 'evil-motion-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-motion)))
(add-hook 'evil-visual-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-visual)))
(add-hook 'evil-operate-state-entry-hook
          (lambda () (anerenv/hl-line-evil/set-hl-state 'hl-line-operate)))
#+end_src

** Line wrap

Don't want to have to scroll to see more chars.

#+begin_src emacs-lisp
(global-visual-line-mode t)
#+end_src

** Parenthesis

Highlight matching parenthesis

#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

** Tabs

Using spaces instead of tabs, default offset is 4.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4
              c-basic-offset 4
              tab-always-indent 'complete)
#+end_src

** BIDI and lang

Setting up Hebrew as alternative input, using bidi mode so that every line is
aligned left\right accordingly.

#+begin_src emacs-lisp
(setq-default default-input-method "hebrew"
              bidi-display-reordering t
              bidi-paragraph-direction 'nil)

(defun anerenv/set-bidi-env ()
    (setq bidi-paragraph-direction 'nil)
)

(define-key anerenv-global-minor-mode-map
    (kbd "C-SPC") 'toggle-input-method)
#+end_src

** Whitespace mode

We define a custom global-whitespace-mode in order to enable it only on
relevant modes.

We check if the current mode doesn't derive from a set of blacklisted mode, the
main culprit being terminal modes where whitespace occur naturally and are a
pain to see all the time.

#+begin_src emacs-lisp
(setq-default whitespace-style
      '(face tabs trailing tab-mark
             lines-tail indentation))

(defun anerenv/whitespace-mode-func ()
  (interactive)
    (if (derived-mode-p 'text-mode 'prog-mode 'org-mode)
        (whitespace-mode 1) (whitespace-mode -1)))

(add-hook 'after-change-major-mode-hook 'anerenv/whitespace-mode-func)
#+end_src

** Commenter

Quick keybindings to comment out regions.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :config
  (define-key evil-normal-state-map (kbd "C-;")
    'evilnc-comment-or-uncomment-lines))
#+end_src

** Irony-mode

Must work on this. While it does work, can get slow and for weird projects can
show errors.

#+begin_src emacs-lisp
;; == irony-mode ==
(use-package irony
  :ensure t
  :defer t
  :init
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)
  :config
  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))
  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  )
#+end_src

** Company mode

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :defer t
  :init (add-hook 'after-init-hook 'global-company-mode)
  :config
  (use-package company-irony :ensure t :defer t)
  (setq
        company-minimum-prefix-length   2
        company-show-numbers            t
        company-tooltip-limit           20
        company-idle-delay              0.2
  )
  :bind ("C-;" . company-complete-common)
  :hook (irony-mode . company-mode)
  )
#+end_src

** Flycheck

#+begin_src emacs-lisp
(use-package flycheck-irony
  :after flycheck
  :config
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)
    (add-hook 'c++-mode-hook (lambda () (setq flycheck-checker 'irony)))
)
#+end_src

** HTMLize

#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

** Folding

Using Hideshow

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** Emojis!

#+begin_src emacs-lisp
(use-package emojify
  :hook (after-init . global-emojify-mode)
  :config (setq use-default-font-for-symbols nil))
#+end_src

:smile:

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :init
  (setq olivetti-body-width 96))
#+end_src

** Pandoc

Pandoc mode lets us export different formats to PDF.

Added for use with markdown.

Binding to startup is 'C-c /'

#+begin_src emacs-lisp
(use-package pandoc-mode
  :hook
  (markdown-mode . pandoc-mode))
#+end_src

* Major modes

** VTerm

#+begin_src emacs-lisp
(use-package vterm
  :if  (member system-type '(gnu gnu/linux))
  :config
    (add-hook 'vterm-mode-hook
            (lambda () (setq-local global-hl-line-mode nil)))

    (evil-collection-define-key 'normal 'vterm-mode-map
      (kbd "p") 'vterm-yank)
)
#+end_src

** Eshell

Watch based on https://emacs.stackexchange.com/questions/44389/how-to-watch-and-cat-and-grep-with-emacs

#+begin_src emacs-lisp
(use-package eshell
  :straight (:type built-in)

  :config
    (add-hook 'eshell-mode-hook (company-mode -1))
)

(defvar watch-history nil)
(defun eshell/watch (command &optional name)
    "Runs \"watch COMMAND\" in a `term' buffer.  \"q\" to exit."
    (interactive
    (list (read-from-minibuffer "watch " nil nil nil 'watch-history)))
    (let* ((name (or name (concat "watch " command)))
            (switches (split-string-and-unquote command))
            (termbuf (apply 'make-term name "watch" nil switches))
            (proc (get-buffer-process termbuf)))
        (set-buffer termbuf)
        (term-mode)
        (term-char-mode)
        (setq-local show-trailing-whitespace nil)
        ;; Kill the process interactively with "q".
        (set-process-query-on-exit-flag proc nil)
        (let ((map (make-sparse-keymap))
            (cmdquit (make-symbol "watch-quit")))
        (put cmdquit 'function-documentation "Kill the `watch' buffer.")
        (put cmdquit 'interactive-form '(interactive))
        (fset cmdquit (apply-partially 'kill-process proc))
        (set-keymap-parent map (current-local-map))
        (define-key map (kbd "q") cmdquit)
        (use-local-map map))
        ;; Kill the buffer automatically when the process is killed.
        (set-process-sentinel
        proc (lambda (process signal)
                (and (memq (process-status process) '(exit signal))
                    (buffer-live-p (process-buffer process))
                    (kill-buffer (process-buffer process)))))
        ;; Display the buffer.
        (switch-to-buffer termbuf)))
#+end_src

#+begin_src emacs-lisp
(use-package conda
  :config
  (conda-env-initialize-eshell))
#+end_src

** PDF-Tools

For viewing PDF files and such!
Broken for the time being
#+begin_src emacs-lisp
(use-package pdf-tools
  :config
    (pdf-tools-install)
    (add-hook 'pdf-view-mode-hook
        (lambda () (blink-cursor-mode 0)))
    (add-hook 'pdf-view-mode-hook 'pdf-view-fit-page-to-window)

    (evil-collection-pdf-setup)
)
#+end_src

*** Stop the blinking on PDF-View-Mode

Taken from [[https://github.com/munen/emacs.d/blob/master/configuration.org][Munen's configuration on GitHub]].
When using evil-mode and pdf-tools and looking at a zoomed PDF, it will blink, because the cursor blinks.
This configuration disables this whilst retaining the blinking cursor in other modes.
Disabled for now
#+begin_src emacs-lisp
;(evil-set-initial-state 'pdf-view-mode 'emacs)
;(add-hook 'pdf-view-mode-hook
;  (lambda ()
;    (set (make-local-variable 'evil-emacs-state-cursor) (list nil))))
#+end_src

** Graphviz

#+begin_src emacs-lisp
(use-package graphviz-dot)
#+end_src

** ORG

*** Base

All things org!

Setting fixed fonts in org-mode so that mixed type works as intended.

#+begin_src emacs-lisp
(defvar anerenv/org-base-dir
    (concat (getenv "HOME") "/org/")
    "Base directory for org files.")

(defun anerenv/set-org-mode-fixed-pitch-faces ()
    (mapc (lambda (face) (set-face-attribute face nil
                :font (face-attribute 'fixed-pitch :font)
                :height (face-attribute 'fixed-pitch :height)))
    `(line-number
        org-block
        org-special-keyword
        org-drawer
        org-todo
        org-done
        org-priority
        org-checkbox
        org-block-end-line
        org-block-begin-line
        org-table
        org-verbatim)))

(use-package org
    :straight
        (:type built-in)
    :hook
        (org-mode . variable-pitch-mode)
        (org-mode . anerenv/set-bidi-env)
        (org-mode . (lambda ()
            (setq-local whitespace-style '(face tabs trailing tab-mark
            indentation))))
    :config
        (anerenv/set-org-mode-fixed-pitch-faces)
        (setq org-src-tab-acts-natively t
              org-adapt-indentation nil
              org-startup-folded t
              org-hide-emphasis-markers t)
        (set-face-attribute 'org-code nil
            :family (face-attribute 'fixed-pitch :family))
        (set-face-attribute 'org-block nil
            :family (face-attribute 'fixed-pitch :family))
    :bind
        ("C-a" . nil)
        ("C-a l" . org-toggle-latex-fragment)
)
#+end_src

*** Capture

Basic setup for org-capture.

One thing of note is that when we insert the project name in org-capture, we replace
the project name's dashes with underlines. This is because we would like to make them
into tags, and org mode tags do not support dashes, but they do support underlines.

#+begin_src emacs-lisp
(setq org-agenda-files (list (concat anerenv/org-base-dir "agenda"))
      org-default-notes-file (concat anerenv/org-base-dir "agenda/notes.org")
      org-agenda-tags-column -80
      org-agenda-start-on-weekday nil)

(define-key anerenv-global-minor-mode-open-map
    (kbd "c") 'counsel-org-capture)

(add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

#+begin_src emacs-lisp
(defvar anerenv/org-capture-default-proj-name
  "general"
  "Default project name")

(defvar anerenv/org-capture-proj-name
  anerenv/org-capture-default-proj-name
  "Temporary var to store prev buffers proj name before capture")

(defun anerenv/org-capture-get-project-name ()
  "Gets project name, returns 'general' if not, replaces dashes with underlines"
  (let ((ret (projectile-project-name)))
    (if (string-equal ret "-") "general" (replace-regexp-in-string "-" "_" ret))))

(defun anerenv/org-capture-set-project-name (&rest args)
  "Sets variable with project name"
  (setq anerenv/org-capture-proj-name (anerenv/org-capture-get-project-name)))

(advice-add 'org-capture :before 'anerenv/org-capture-set-project-name)

(setq org-capture-templates `(
("tf" "Todo w/file" entry
    (file "agenda/tasks.org")
"* TODO %?%(org-set-tags anerenv/org-capture-proj-name)
:PROPERTIES:
:CREATED: %U
:FILE: %l
:PROJECT: %(eval anerenv/org-capture-proj-name)
:END:\n")

("tp" "Todo w/project" entry
    (file "agenda/tasks.org")
"* TODO %?%(org-set-tags anerenv/org-capture-proj-name)
:PROPERTIES:
:CREATED: %U
:PROJECT: %(eval anerenv/org-capture-proj-name)
:END:\n")

("tdf" "Todo w/deadline, file" entry
    (file "agenda/tasks.org")
"* TODO %^t %?%(org-set-tags anerenv/org-capture-proj-name)
:PROPERTIES:
:CREATED: %U
:FILE: %l
:PROJECT: %(eval anerenv/org-capture-proj-name)
:END:\n")

("tdp" "Todo w/project, file" entry
    (file "agenda/tasks.org")
"* TODO %^t %?%(org-set-tags anerenv/org-capture-proj-name)
:PROPERTIES:
:CREATED: %U
:FILE: %l
:PROJECT: %(eval anerenv/org-capture-proj-name)
:END:\n")

("tg" "Todo general" entry
    (file "agenda/tasks.org")
"* TODO %?%(org-set-tags \"general\")
:PROPERTIES:
:PROJECT: general
:CREATED: %U
:END:\n")

("tdg" "Todo general w/date" entry
    (file "agenda/tasks.org")
"* TODO %^t %?%(org-set-tags \"general\")
:PROPERTIES:
:PROJECT: general
:CREATED: %U
:END:\n")

("n" "Notes" item
    (file "notes.org")
"%?")

("j" "Journal entry" entry
    (file+datetree "journal/journal.org")
"* %U
:PROPERTIES:
:CREATED: %U
:MOOD: %^{General mood?|happy|angry|sad|neutral}
:ENERGY: %^{Energy?|tired|energetic|neutral}
:END:
%?")
))

(add-hook 'org-capture-prepare-finalize-hook 'org-align-all-tags)
#+end_src

*** Roam

#+begin_src emacs-lisp
(use-package org-roam
    :after org
    :init (setq org-roam-v2-ack t) ;; Acknowledge V2 upgrade
    :custom
    (org-roam-directory (file-truename (concat anerenv/org-base-dir "roam")))
    :config
    (org-roam-setup)

    :bind (("C-c n f" . org-roam-node-find)
           ("C-c n r" . org-roam-node-random)
           (:map org-mode-map
                 (("C-c n i" . org-roam-node-insert)
                  ("C-c n o" . org-id-get-create)
                  ("C-c n t" . org-roam-tag-add)
                  ("C-c n a" . org-roam-alias-add)
                  ("C-c n l" . org-roam-buffer-toggle)))))
#+end_src

*** Agenda

#+begin_src emacs-lisp
(define-key anerenv-global-minor-mode-open-map
    (kbd "a") 'org-agenda)
#+end_src

Setting org agenda to open in current window

#+begin_src emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+end_src

For good keybindings in org agenda we use evil org. But we'll do it only for org agenda.

#+begin_src emacs-lisp
(use-package evil-org
  :ensure t
  :after org
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  ;We don't want the M-j M-k definitions
  (evil-define-key 'motion org-agenda-mode-map
    (kbd "M-j") nil
    (kbd "M-k") nil))
#+end_src

Custom views

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("h" "High priority"
         ((agenda "")
            (tags-todo "priority")
            (tags-todo "general")
          ))
        ("o" "Config"
         ((agenda "")
          (tags-todo "anerenv")))))
#+end_src

*** Cladav

#+begin_src emacs-lisp
(use-package org-caldav)
#+end_src

*** Babel

Define languages to use

#+begin_src emacs-lisp
(require 'ob)
(require 'ob-tangle)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (emacs-lisp . t)
   (python . t)
   (org . t)
   (lilypond . t)
   (latex . t)
   (js . t)
   (java . t)
   (dot . t)
   (C . t)))

(add-to-list 'org-src-lang-modes (quote ("dot". graphviz-dot)))
(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
(add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))
#+end_src

This section makes code-indentation correction work inside source blocks.
Taken from: https://github.com/emacs-evil/evil/issues/1288


#+begin_src emacs-lisp
(defun evil-org-insert-state-in-edit-buffer (fun &rest args)
  "Bind `evil-default-state' to `insert' before calling FUN with ARGS."
  (let ((evil-default-state 'insert)
        ;; Force insert state
        evil-emacs-state-modes
        evil-normal-state-modes
        evil-motion-state-modes
        evil-visual-state-modes
        evil-operator-state-modes
        evil-replace-state-modes)
    (apply fun args)
    (evil-refresh-cursor)))

(advice-add 'org-babel-do-key-sequence-in-edit-buffer
            :around #'evil-org-insert-state-in-edit-buffer)
#+end_src

*** Code blocks

The following displays the contents of code blocks in Org-mode files using
the major-mode of the code. It also changes the behavior of TAB to as if it
were used in the appropriate major mode.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation t)

(set-face-attribute 'org-block nil
    :background "LemonChiffon1")
(set-face-attribute 'org-block-begin-line nil
    :background "LightYellow2")
(set-face-attribute 'org-block-end-line nil
    :background "LightYellow2")
#+end_src

*** PDF exporting

#+begin_src emacs-lisp
(setq org-latex-listings 'minted)
(setq org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(require 'ox-latex)
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))
#+end_src

Creating classes

#+begin_src emacs-lisp
(setq org-latex-classes
     '(("article"
"\\documentclass{article}
[DEFAULT-PACKAGES]
\\usepackage{polyglossia}
\\usepackage[cache=false]{minted}
\\usepackage{xcolor}
\\usepackage{indentfirst}
\\usepackage{amsfonts}
\\usepackage{amsmath}
\\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\\setdefaultlanguage{english}
\\setlength{\\parindent}{0in}

\\setminted{
    bgcolor=codebg,
    breaklines=true,
    mathescape,
    fontsize=\\scriptsize,
    linenos=false,
}
\\DeclareMathOperator*{\\argmax}{arg\\,max}
\\DeclareMathOperator*{\\argmin}{arg\\,min}
\\newfontfamily\\hebrewfont{LiberationSans}[Script=Hebrew]
\\setotherlanguage{hebrew}
"
        ("\\section{%s}" . "\\section*{%s}")
        ("\\subsection{%s}" . "\\subsection*{%s}")
        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
        ("\\paragraph{%s}" . "\\paragraph*{%s}")
        ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

(setq org-export-with-toc nil
      org-export-with-section-numbers nil)
#+end_src

This should render Hebrew text.

#+begin_export latex
\begin{hebrew}
#+end_export
זה אמור לעבוד
#+begin_export latex
\end{hebrew}
#+end_export

*** Latex previews

We don't want to create ltximg directories all over the place.
Let's store all ltximg previews in tmp directory.

Latex scaling from

https://karthinks.com/software/scaling-latex-previews-in-emacs/

#+begin_src emacs-lisp
(setq org-format-latex-header
 "\\documentclass{article}
\\usepackage[usenames]{color}
[PACKAGES]
[DEFAULT-PACKAGES]
\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
\\DeclareMathOperator*{\\argmax}{arg\\,max}
\\DeclareMathOperator*{\\argmin}{arg\\,min}"
 )

(setq org-preview-latex-image-directory (concat user-emacs-directory "ltximg/"))

(setq org-latex-create-formula-image-program 'dvisvgm)

(setq org-format-latex-options (plist-put org-format-latex-options :scale 1))
#+end_src

*** Org block highlighting

#+begin_src emacs-lisp
(use-package color)
#+end_src

*** Fonts

#+begin_src emacs-lisp
(set-face-attribute 'org-document-title nil :height 200 :underline t)
#+end_src

*** Python version

#+begin_src emacs-lisp
(setq org-babel-python-command "python3")
#+end_src

*** Async blocks

#+begin_src emacs-lisp
(use-package ob-async
  :config
    ;Setting command of async blocks to Python3
    (add-hook 'ob-async-pre-execute-src-block-hook
            '(lambda ()
            (setq org-babel-python-command "python3")
    ))
)
#+end_src

*** Inline images

#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)

(defun shk-fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(with-eval-after-load 'org
  (add-hook 'org-babel-after-execute-hook 'shk-fix-inline-images))
#+end_src

*** Snippets

Want to create snippets for latex insertion.
There is one template for inline and one template for standalone latex snippets.
Each template is defind by two templates. One for other langauges and one for standard
input. This is done to toggle back to the original language once done with the
function toggle-input-method.

#+begin_src emacs-lisp
(defun dumb-toggle-input-method ()
    (if current-input-method (toggle-input-method))
)
;Inline
(add-hook 'org-mode-hook (lambda () (progn
    (yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\$$1\$$0"
                                      "ORG_LATEX_INLINE_SNIPPET_ENG"
                                      '(not (eval current-input-method))
                                      nil
                                      nil
                                      nil
                                      "C-l"
                                      nil
                                      nil
                                      )))

    (yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\$$1\$$0"
                                      "ORG_LATEX_INLINE_SNIPPET_OTHER_LANG"
                                      '(eval current-input-method)
                                      nil
                                      '((unused (dumb-toggle-input-method))
                                        (yas-after-exit-snippet-hook 'toggle-input-method))
                                      nil
                                      "C-l"
                                      nil
                                      nil
                                      )))

    ;Not inline
    (yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\$\$$1\$\$$0"
                                      "ORG_LATEX_OUTLINE_SNIPPET_ENG"
                                      '(not (eval current-input-method))
                                      nil
                                      nil
                                      nil
                                      "C-S-l"
                                      nil
                                      nil
                                      )))
    (yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\$\$$1\$\$$0"
                                      "ORG_LATEX_OUTLINE_SNIPPET_OTHER_LANG"
                                      '(eval current-input-method)
                                      nil
                                      '((unused (dumb-toggle-input-method))
                                        (yas-after-exit-snippet-hook 'toggle-input-method))
                                      nil
                                      "C-S-l"
                                      nil
                                      nil
                                      )))
    )))
#+end_src

Snippet for src blocks

#+begin_src emacs-lisp
(add-hook 'org-mode-hook (lambda () (progn
    (yas-define-snippets 'org-mode (list (list
                                      nil
                                      "#+begin_src $1\n$0\n\n#+end_src"
                                      "ORG_SRC_BLOCK"
                                      nil
                                      nil
                                      nil
                                      nil
                                      "C-c i b"
                                      nil
                                      nil
                                      )))

    (yas-define-snippets 'org-mode (list (list
                                      nil
                                      (concat
                                        "#+begin_export latex\n"
                                        "\\begin{english}\n"
                                        "#+end_export\n"
                                        "#+begin_src $1\n"
                                        "$0\n"
                                        "\n#+end_src\n"
                                        "#+begin_export latex\n"
                                        "\\end{english}\n"
                                        "#+end_export")
                                      "ORG_SRC_ENGLISH_BLOCK"
                                      nil
                                      nil
                                      nil
                                      nil
                                      "C-c i B"
                                      nil
                                      nil
                                      )))
)))
#+end_src

*** Presentation

#+begin_src emacs-lisp
(use-package org-present
  :config
    (add-hook 'org-present-mode-hook (lambda ()
            (evil-emacs-state)
            (blink-cursor-mode 0)
            (org-present-big)
            (org-display-inline-images)
            (org-present-read-only)
            (setq-local global-hl-line-mode nil)
            (org-present-hide-cursor)
            (olivetti-mode 1)
            (display-line-numbers-mode 0)))

    (add-hook 'org-present-mode-quit-hook (lambda ()
            (org-present-small)
            (blink-cursor-mode 1)
            (org-remove-inline-images)
            (org-present-show-cursor)
            (org-present-read-write)
            (evil-normal-state)
            (setq-local global-hl-line-mode 1)
            (olivetti-mode 0)
            (display-line-numbers-mode 1)))
)
#+end_src

*** Formatter

https://emacs.stackexchange.com/questions/16792/easiest-way-to-check-if-current-line-is-empty-ignoring-whitespace
https://stackoverflow.com/questions/52121961/emacs-org-mode-insert-text-after-heading-properties
https://stackoverflow.com/questions/4419576/delete-extra-blank-lines-in-emacs

#+begin_src emacs-lisp
(defun anerenv/testfunc () (interactive)
       (org-end-of-meta-data t)
)

(defun anerenv/current-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at-p "[[:space:]]*$")))

(defun anerenv/format-org ()
  "Formats org buffer to proper format"
  (interactive)
  (save-excursion ;Make sure not to actually change cursor position
    (save-match-data ;Don't mess with search data
      (progn
        (goto-char (point-min)) ;Reset after each search through

        ;For each org header, check if prev line is empty. If not, make it
        (while (re-search-forward org-heading-regexp nil t) ;For each org header
            (if (not (eq (line-beginning-position) (point-min))) (progn
                (previous-line 1)
                (if (anerenv/current-line-empty-p)
                    (next-line 2)
                    (progn
                        (next-line 1)
                        (goto-char (line-beginning-position))
                        (newline)
                        (next-line 1))))))

        (goto-char (point-min))
        ;For each org header, check if next line is empty (after metadata)
        (while (re-search-forward org-heading-regexp nil t)
            (org-end-of-meta-data t)
            (goto-char (line-beginning-position))
            (if (not (anerenv/current-line-empty-p))
                    (newline)))

        (goto-char (point-min))
        ;Delete extra newlines
        (while (re-search-forward "\\(^\\s-*$\\)\n" nil t)
            (replace-match "\n")
            (forward-char 1))

        ;Finally, general whitespace cleanup
        (whitespace-cleanup)))))
#+end_src

*** Imenu quirks

#+begin_src emacs-lisp
(add-to-list 'org-show-context-detail '(isearch . tree))
(add-to-list 'org-show-context-detail '(default . tree))
#+end_src

*** Useful to remember

To preview latex fragment as image embedded in text
#+begin_example
org-toggle-latex-fragment
#+end_example

** Markdown

Based on [[https://www.reddit.com/r/emacs/comments/u5owr4/how_to_enable_variablepitchmode_for_markdownmode/][this]] post
detailing variable pitch.

We default to github-flavored markdown and show it as variable pitch.

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode (("\\.md$" . gfm-mode)
         ("\\.mkd$" . gfm-mode))
  :hook (gfm-mode . variable-pitch-mode)
  :diminish markdown-live-preview-mode
  :config
  (when (bound-and-true-p lsp-mode)
    (variable-pitch-mode -1))
  (set-face-attribute 'markdown-pre-face nil
    :background "LemonChiffon1" :extend t)
  )
#+end_src

Let's add a TOC

#+begin_src emacs-lisp
(use-package markdown-toc)
#+end_src

** CMake

#+begin_src emacs-lisp
(use-package cmake-mode)
#+end_src

** Racket

#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** Typescript

#+begin_src emacs-lisp
(use-package typescript-mode)
#+end_src

** Mail

*** General instructions

Due to the fact that setting up email in general is complicated, I'll recap the process here.

Before ANYTHING, setup pass.

https://wiki.archlinux.org/title/Pass

Initialize password

Then for gmail, used

#+begin_src bash :results none :exports code
pass init <ID>
pass insert gmail.com/<username>
#+end_src

It prompted for password, I put it in.

Then setup mbsync properly. The ansible files already take care of that.

Then we setup ~/.mbsyncrc. This file is important and is not linked to repository for security reasons.

https://wiki.archlinux.org/title/isync

Wrote mbsyncrc

Created all directories

Went into gmail settings to allow less secure things.

https://notmuchmail.org/getting-started/

We then RUN notmuch, and notmuch setup for prompt.

Adding emails can be done with notmuch new

*** Config

#+begin_src emacs-lisp
(defvar anerenv/mail/sync-list nil "List of functions with args to sync mail")

(defun anerenv/mail/lieer-sync-func-str (maildir)
  (concat "cd " maildir " && gmi sync -s"))

(defun anerenv/mail/mbsync-func-str ()
    "mbsync -a")

(defun anerenv/mail/pre-sync-func-str ()
    (concat (mapconcat 'eval (mapcar 'apply anerenv/mail/sync-list) " &\n")
        "\nwait\n"))

(defun anerenv/mail/sync-notify () (interactive)
  (let ((command (concat (anerenv/mail/pre-sync-func-str)
                         "{ if [[ $(notmuch new | grep \"No new mail\") ]]; "
                         "then dunstify -u low \"Synced mail\" ; "
                         "else dunstify \"New mail!\" ; fi ; } || "
                         "dunstify -u critical \"Error syncing mail\"")))
    (start-process-shell-command "mailsync" "*mailsync*" command)))

(defun anerenv/mail/sync-n-notify ()
  (let ((command (concat (anerenv/mail/pre-sync-func-str)
                         "{ if [[ $(notmuch new | grep \"No new mail\") ]]; "
                         "then : ; "
                         "else dunstify \"New mail!\" ; fi ; } || "
                         "dunstify -u critical \"Error syncing mail\"")))
    (start-process-shell-command "mailsync" "*mailsync*" command)))

(defun anerenv/mail/set-sync-list (sync-list)
    "Set list of mails and start timer"
    (progn
        (setq anerenv/mail/sync-list sync-list)
        (anerenv/run-timer 'mail-sync 'anerenv/mail/sync-n-notify (* 60 10))))

(use-package notmuch
  :straight (:type built-in)
  :init
    (setq-default
        notmuch-hello-sections
            '(notmuch-hello-insert-saved-searches
              notmuch-hello-insert-alltags)
        notmuch-search-oldest-first t
        notmuch-always-prompt-for-sender t
        message-sendmail-envelope-from 'header)
  :config
    (evil-collection-notmuch-setup)
    (add-hook 'notmuch-show-mode 'anerenv/default-variable-pitch)
    (setq send-mail-function 'sendmail-send-it)
    (defun anerenv/notmuch-archive () "Archive a message" (interactive)
        (progn
            (evil-collection-notmuch-toggle-tag "arx" "search" 'ignore)
            (evil-collection-notmuch-toggle-tag "inbox" "search"
                                                'notmuch-search-next-thread)
            ))
    (defun anerenv/notmuch-delete-gmail () "Delete a message, no inbox"
        (interactive)
        (progn
            (evil-collection-notmuch-toggle-tag "deleted" "search" 'ignore)
            (evil-collection-notmuch-toggle-tag "trash" "search" 'ignore)
            (evil-collection-notmuch-toggle-tag "inbox" "search" 'notmuch-search-next-thread)
            ))
    (defun anerenv/notmuch-toggle-inbox () "Toggles inbox tag" (interactive)
            (evil-collection-notmuch-toggle-tag "inbox" "search" 'ignore))
    (dolist (state '(normal visual))
        (evil-collection-define-key state 'notmuch-search-mode-map
          "d" 'anerenv/notmuch-delete-gmail
          "I" 'anerenv/notmuch-toggle-inbox
          "D" 'evil-collection-notmuch-search-toggle-delete
          "A" 'anerenv/notmuch-archive))
    (evil-collection-define-key 'normal 'notmuch-show-mode-map
        (kbd "M-j") nil
        (kbd "M-k") nil)

  :bind
    (:map anerenv-global-minor-mode-open-map
        ("m" . notmuch))
)
#+end_src

Run this command to make sendmail use the right thing

#+begin_src bash :results none :exports code
sudo ln -s /usr/bin/msmtp /usr/sbin/sendmail
#+end_src

Then we go to

https://wiki.archlinux.org/title/isync

We will do this manually.

*** Signatures

Taken from

https://emacs.stackexchange.com/questions/27759/do-not-automatically-sign-emails-directed-to-mailing-lists-and-such

Thanks to Dan of Stackoverflow.

#+begin_src emacs-lisp


(defvar anerenv/mail/blacklist-addresses nil
  "List of email addresses (as strings) to blacklist for
  `mml-secure-message-sign'.")

(defun anerenv/mail/secure-sign-maybe ()
  "Use `mml-secure-message-sign' unless the addressee is in the
`anerenv/mail/blacklist-addresses'."
  (let ((addresses (mapcar (lambda (address)
                             (when (string-match
                                    "\\(<?\\)\\([^@< ]+@[^@> ]+\\)\\(>?\\)"
                                    address)
                               (match-string 2 address)))
                           ;; (split-string (message-field-value "To")
                           ;;               "," t "[[:blank:]]+"))))
                           (split-string (concat (message-field-value "To")
                                                 ", "
                                                 (message-field-value "Cc"))
                                         "," t "[[:blank:]]+"))))
    ;; skip secure signing when an address is blacklisted
    (unless (delq nil (mapcar (lambda (address)
                    (car (member address anerenv/mail/blacklist-addresses)))
                    addresses))
      (mml-secure-message-sign))))
#+end_src

** LEETCODE

#+begin_src emacs-lisp
(require 'subr-x)

(use-package leetcode)
#+end_src

** Proced

#+begin_src emacs-lisp
(evil-collection-proced-setup)
#+end_src

** Elfeed

MPV from https://www.reddit.com/r/emacs/comments/7usz5q/youtube_subscriptions_using_elfeed_mpv_no_browser/

https://medium.com/emacs/using-elfeed-to-view-videos-6dfc798e51e6

#+begin_src emacs-lisp
(defun load-ytsublist-channels ()
    "Loads into elfeed-feeds all channels from ~/.config/ytsubs-channels"
    (if (file-exists-p "~/.config/ytsubs-channels")
        (dolist
            (yt-id (split-string
            (slurp "~/.config/ytsubs-channels") "\n" t))
            (add-to-list 'elfeed-feeds
                (concat
                "https://www.youtube.com/feeds/videos.xml?channel_id="
                    yt-id)))))

(defun load-ytsublist-users ()
    "Loads into elfeed-feeds all users from ~/.config/ytsubs-users"
    (if (file-exists-p "~/.config/ytsubs-users")
        (dolist
            (yt-id (split-string
            (slurp "~/.config/ytsubs-users") "\n" t))
            (add-to-list 'elfeed-feeds
                (concat
                    "https://www.youtube.com/feeds/videos.xml?user="
                    yt-id)))))

(use-package elfeed
    :init
        (defun elfeed-v-mpv (url)
            "Watch a video from URL in MPV"
            (start-process "mpv" nil "mpv" url))

        (defun elfeed-view-mpv (&optional use-generic-p)
        "Youtube-feed link"
        (interactive "P")
        (let ((entries (elfeed-search-selected)))
            (cl-loop for entry in entries
            do (elfeed-untag entry 'unread)
            when (elfeed-entry-link entry)
            do (elfeed-v-mpv it))
        (mapc #'elfeed-search-update-entry entries)))

        (defun slurp (f)
        (with-temp-buffer
            (insert-file-contents f)
            (buffer-substring-no-properties
            (point-min)
            (point-max))))

        (setq-default elfeed-search-filter "@3-days-ago")
    :config
        (define-key elfeed-search-mode-map (kbd "C-c v") 'elfeed-view-mpv)
        (evil-collection-elfeed-setup)
        (load-ytsublist-channels)
        (load-ytsublist-users)
)
#+end_src

** Pass

#+begin_src emacs-lisp
(use-package pass
  :bind
    (:map anerenv-global-minor-mode-open-map
        ("p" . 'password-store-copy)))
#+end_src

** Chess

#+begin_src emacs-lisp
(use-package chess
  :config
  (setq chess-images-separate-frame nil
        chess-images-default-size 60
        chess-images-dark-color "LightYellow3"
        chess-images-light-color "LightYellow2"
        chess-images-white-color "gray100"
        chess-images-black-color "gray10")
  ;Disable evil
  (add-to-list 'evil-emacs-state-modes 'chess-display-mode)
  ;Disable hl-line-mode
  (advice-add 'chess-display-mode
  :before '(lambda () (setq-local global-hl-line-mode nil)))
)

;Added for config purposes
(require 'chess)
(require 'chess-ics)
#+end_src

#+begin_src emacs-lisp
(use-package pygn-mode
  :bind
  (:map pygn-mode-map
    ("C-<right>" . 'pygn-mode-next-move-follow-board)
    ("C-<left>" . 'pygn-mode-previous-move-follow-board)
    ("C-c C-c" . 'pygn-mode-display-gui-board-at-pos)))
#+end_src

#+begin_src emacs-lisp
(defvar anerenv/chess/pgn-default-dir (getenv "HOME")
  "Default dir for pgn")

(defun anerenv/chess/curr-game-pgn-string () "Get current game as PGN"
       (chess-game-to-pgn chess-module-game 1 0))

(defun anerenv/chess/yank-pgn-string () "Get current game as PGN"
       (interactive)
       (kill-new (anerenv/chess/curr-game-pgn-string)))

(defun anerenv/chess/save-pgn () "Save current game to PGN"
       (interactive)
       (let ((pgn-str (anerenv/chess/curr-game-pgn-string)))
         (with-temp-file
             (read-file-name "Save PGN of game to:"
                             anerenv/chess/pgn-default-dir
                             nil nil
                             (format-time-string "game--%Y-%m-%d--%H-%M-%S.pgn"))
           (insert pgn-str))))
#+end_src

#+begin_src emacs-lisp
(setq chess-default-display '(chess-images chess-ics1 chess-plain))
#+end_src

** Ibuffer

#+begin_src emacs-lisp
(evil-collection-ibuffer-setup)
(define-key anerenv-global-minor-mode-map
    (kbd "C-x C-b") 'ibuffer)
#+end_src

** Wiki-summary

#+begin_src emacs-lisp
(use-package wiki-summary)
#+end_src

** Dashboard

#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
(use-package dashboard
  :config
  (add-hook 'after-init-hook
            (lambda () (dashboard-insert-startupify-lists)))
  (add-hook 'emacs-startup-hook (lambda ()
                                  (switch-to-buffer dashboard-buffer-name)
                                  (goto-char (point-min))
                                  (redisplay)
                                  (run-hooks 'dashboard-after-initialize-hook)))
  (add-to-list 'evil-emacs-state-modes 'dashboard-mode)
  (setq dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5))
        dashboard-center-content t
        dashboard-set-init-info nil
        dashboard-set-footer nil
        dashboard-startup-banner nil)
  ;; (defun anerenv/stupid-func () (message "Cheese whiz!"))
  ;; (defun dashboard-insert-custom (list-size)
  ;;     (insert "Custom text"))
  ;; (add-to-list 'dashboard-item-generators  '(anerenv/stupid-func . dashboard-insert-custom))
  ;; (add-to-list 'dashboard-items '(anerenv/stupid-func) t)
)
#+end_src

** Calendar

#+begin_src emacs-lisp
(evil-collection-calendar-setup)
#+end_src

** Dired

Need to autoload dired-x for dired-omit
#+begin_src emacs-lisp
(autoload 'dired-omit-mode "dired-x")
(setq dired-omit-files "^\\...+$")
(add-hook 'dired-mode-hook 'dired-omit-mode)
(add-hook 'dired-mode-hook 'dired-hide-details-mode)
(evil-collection-dired-setup)
#+end_src

#+begin_src emacs-lisp
(use-package dired-subtree
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
        (kbd "SPC") 'dired-subtree-toggle
        (kbd "TAB") 'dired-subtree-cycle
        )
    (setq dired-subtree-use-backgrounds nil)
    ;Evil collection binds these keys, we need them for window movement
    (evil-collection-define-key 'normal 'dired-mode-map
        (kbd "M-j") nil
        (kbd "M-k") nil)
)

#+end_src

** Magit

#+begin_src emacs-lisp
(use-package magit
    :config
        (evil-collection-magit-setup)
    :bind
        (:map anerenv-global-minor-mode-open-map
            ("g" . 'magit-status))
)
#+end_src

** EAF
*** EAF - Base

The Emacs application framework!

For customization see https://github.com/emacs-eaf/emacs-application-framework/wiki/Customization

#+begin_src emacs-lisp
;; (add-to-list 'load-path "~/.git-repos/eaf/")
;; (require 'eaf)
;; (add-to-list 'evil-emacs-state-modes 'eaf-mode)
#+end_src

*** EAF - Browser

#+begin_src emacs-lisp
;; (require 'eaf-browser)
;; (setq eaf-browser-continue-where-left-off t
;;       eaf-browser-enable-adblocker t
;;       browse-url-browser-function 'eaf-open-browser
;;       eaf-browser-download-path "~/downloads")
;; (defalias 'browse-web #'eaf-open-browser)
;; (define-key anerenv-global-minor-mode-open-map
;;     (kbd "w") 'eaf-open-browser)
;; (define-key anerenv-global-minor-mode-open-map
;;     (kbd "W") 'eaf-open-browser-with-history)
#+end_src

Unbinding unwanted key bindings
#+begin_src emacs-lisp
;; ;Unbinding dark mode keymap
;; (eaf-bind-key nil "M-d" eaf-browser-keybinding)
;; (eaf-bind-key nil "M-o" eaf-browser-keybinding)

;; (dolist
;;     (k '("M-d" "M-o" "M-b" "n"))
;;   (eaf-bind-key nil k eaf-browser-keybinding))
#+end_src

Rebinding wanted functionality
#+begin_src emacs-lisp
;; (defun anerenv/eaf-interactive-search-it ()
;;   (interactive)
;;     (setq current-prefix-arg '(1)) (call-interactively 'eaf-search-it))

;; (eaf-bind-key edit_url "C-o" eaf-browser-keybinding)
;; (eaf-bind-key history_forward "C-f" eaf-browser-keybinding)
;; (eaf-bind-key history_backward "C-b" eaf-browser-keybinding)
;; (eaf-bind-key open_link "C-v" eaf-browser-keybinding)
;; (eaf-bind-key open_link_new_buffer "C-S-v" eaf-browser-keybinding)
;; (eaf-bind-key export_text "C-e" eaf-browser-keybinding)
;; (eaf-bind-key anerenv/eaf-interactive-search-it "C-f" eaf-browser-keybinding)
#+end_src

*** EAF - Terminal

#+begin_src emacs-lisp
;; (require 'eaf-terminal)
#+end_src

*** EAF - Video Player

#+begin_src emacs-lisp
;; (require 'eaf-video-player)
#+end_src

** Python

#+begin_src emacs-lisp
(setq
    ;; python-shell-interpreter "python3"
    python-shell-completion-native-enable nil)

(defun anerenv/python/set-fringes () "Sets fringes for python"
       (setq left-fringe-width 10 right-fringe-width 0))

(add-hook 'python-mode-hook 'anerenv/python/set-fringes)

(use-package elpy
  :ensure t
  :defer t
  :init
  (elpy-enable))

(define-key anerenv-global-minor-mode-open-map
  (kbd "r p") 'run-python)
#+end_src

** Jupyter

#+begin_src emacs-lisp
(use-package ein)
#+end_src

** OpenSCAD

#+begin_src emacs-lisp
(use-package scad-mode)

(use-package scad-preview
  :straight '(
              scad-preview
              :type git
              :host github
              :repo "zk-phi/scad-preview"))
#+end_src

** Weather (WTTR)

#+begin_src emacs-lisp
(use-package wttrin)
#+end_src

** EPUB

#+begin_src emacs-lisp
(use-package nov
  :config
  (evil-collection-nov-setup)
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  )
#+end_src

** Github

#+begin_src emacs-lisp
(use-package gh)
#+end_src

** Pomodoro

#+begin_src emacs-lisp
(defvar anerenv/pomodoro/work-time (* 60 25)
  "Work time for Pomodoro in seconds")

(defvar anerenv/pomodoro/rest-time (* 60 5)
  "Rest time for Pomodoro in seconds")

(defvar anerenv/pomodoro/current-task nil "The current Pomodoro task")

(defvar anerenv/pomodoro/current-work-time nil
  "Work time for current Pomodoro in seconds")

(defvar anerenv/pomodoro/current-rest-time nil
  "Rest time for current Pomodoro in seconds")

(defvar anerenv/pomodoro/current-start-time nil
  "Start time for Pomodoro in seconds")

(defvar anerenv/pomodoro/current-work-end-time nil
  "End time for Pomodoro work")

(defvar anerenv/pomodoro/current-rest-end-time nil
  "End time for Pomodoro rest")

(defvar anerenv/pomodoro/journal-file "journal/pomodoro-journal.org"
  "Pomodoro journal file")

(defvar anerenv/pomodoro/start-again-on-stop t
  "Whether to start a new timer when previous finishes")

(defvar anerenv/pomodoro/is-paused nil
  "Whether Pomodoro timer is paused")   ;

(add-to-list 'org-capture-templates
             (list "ptje" "Pomodoro log" 'entry
                   (list 'file+datetree anerenv/pomodoro/journal-file)
                   "* %U-%((lambda () anerenv/pomodoro/current-task))"
                   :immediate-finish t))

(add-to-list 'org-capture-templates
             (list "ptjc" "Pomodoro log early stop" 'entry
                   (list 'file+datetree anerenv/pomodoro/journal-file)
                   "* %U-%((lambda () anerenv/pomodoro/current-task)) :cancelled"
                   :immediate-finish t))

(defun anerenv/pomodoro/pause () "Pauses pomodoro" (interactive)
       (if anerenv/pomodoro/current-task
            (if (not anerenv/pomodoro/is-paused)
                (progn
                    (notifications-notify
                        :title "Pomodoro"
                        :body "Pausing timer!!"
                        :urgency 'low)
                    (anerenv/kill-timer 'pomodoro/rest)
                    (anerenv/kill-timer 'pomodoro/stop)
                    (setq anerenv/pomodoro/current-work-time
                            (time-to-seconds (time-subtract (current-time)
                                    anerenv/pomodoro/current-start-time))
                            anerenv/pomodoro/current-start-time nil
                            anerenv/pomodoro/current-work-end-time nil
                            anerenv/pomodoro/current-rest-end-time nil
                            anerenv/pomodoro/is-paused t)
                    ))
         (progn (message "No Pomodoro task!")
                (anerenv/kill-timer 'pomodoro/stop))))

(defun anerenv/pomodoro/resume () (interactive)
       "Resume the pomodoro timer"
         (if (and anerenv/pomodoro/current-task anerenv/pomodoro/is-paused)
             (progn
               (let ((currtime (current-time)))
                (setq
                 anerenv/pomodoro/is-paused nil
                 anerenv/pomodoro/current-work-end-time
                     (time-add currtime anerenv/pomodoro/current-work-time)
                 anerenv/pomodoro/current-rest-end-time
                     (time-add anerenv/pomodoro/current-work-end-time
                               anerenv/pomodoro/current-work-time)
                 anerenv/pomodoro/current-rest-end-time nil)
                (notifications-notify
                    :title "Pomodoro"
                    :body "Unpaused timer!!"
                    :urgency 'low)
                (anerenv/run-one-time-task
                    'pomodoro/rest 'anerenv/pomodoro/rest
                    (+ anerenv/pomodoro/current-work-time))
                (anerenv/run-one-time-task
                    'pomodoro/stop 'anerenv/pomodoro/stop
                    (+ anerenv/pomodoro/current-work-time
                        anerenv/pomodoro/current-rest-time))))
            (message "Pomodoro timer either doesn't exist or is not paused!")))

(defun anerenv/pomodoro/stop () "Stops pomodoro"
    (progn
        (notifications-notify
            :title "Pomodoro"
            :body "Finished resting!"
            :urgency 'low)
        (setq anerenv/pomodoro/is-paused nil
              anerenv/pomodoro/current-work-time nil
              anerenv/pomodoro/current-rest-time nil
              anerenv/pomodoro/current-task nil
              anerenv/pomodoro/current-work-end-time nil
              anerenv/pomodoro/current-rest-end-time nil
              anerenv/pomodoro/current-start-time nil)
        (if anerenv/pomodoro/start-again-on-stop
            (anerenv/pomodoro/start))))

(defun anerenv/pomodoro/cancel () "Cancels pomodoro"
       (interactive)
       (progn
         (if anerenv/pomodoro/current-task
             (org-capture nil "ptje"))
         (setq anerenv/pomodoro/is-paused nil
               anerenv/pomodoro/current-work-time nil
               anerenv/pomodoro/current-rest-time nil
               anerenv/pomodoro/current-work-end-time nil
               anerenv/pomodoro/current-rest-end-time nil
               anerenv/pomodoro/current-task nil
               anerenv/pomodoro/current-start-time nil)))

(defun anerenv/pomodoro/rest () "Rest pomodoro"
       (progn
         (org-capture nil "ptje")
         (setq anerenv/pomodoro/current-work-time nil
               anerenv/pomodoro/current-task nil
               anerenv/pomodoro/current-work-end-time nil
               )
         (notifications-notify
          :title "Pomodoro"
          :body "Rest time started"
          :urgency 'low)))

(defun anerenv/pomodoro/start ()
       "Start the pomodoro timer"
       (interactive)
        (if (or (not anerenv/pomodoro/current-task) (y-or-n-p
                                            "A task already exists. Cancel?"))
            (let ((currtask (read-string "Enter task: "))
                  (currtime (current-time)))
                (if currtask (progn
                    (if anerenv/pomodoro/current-task
                        (anerenv/pomodoro/cancel))
                    (setq anerenv/pomodoro/current-start-time (current-time)
                          anerenv/pomodoro/current-task currtask
                          anerenv/pomodoro/current-work-time
                                anerenv/pomodoro/work-time
                          anerenv/pomodoro/current-rest-time
                                anerenv/pomodoro/rest-time
                          anerenv/pomodoro/current-work-end-time
                                (time-add currtime
                                          anerenv/pomodoro/current-work-time)
                          anerenv/pomodoro/current-rest-end-time
                                (time-add anerenv/pomodoro/current-work-end-time
                                    anerenv/pomodoro/current-work-time))
                    (anerenv/run-one-time-task
                        'pomodoro/rest 'anerenv/pomodoro/rest
                        (+ anerenv/pomodoro/work-time))
                    (anerenv/run-one-time-task
                        'pomodoro/stop 'anerenv/pomodoro/stop
                        (+ anerenv/pomodoro/current-work-time
                            anerenv/pomodoro/current-rest-time))
                    )))))
#+end_src

* UI

** Modeline

Setting colors

#+begin_src emacs-lisp
(set-face-attribute 'mode-line nil :box nil :background "AliceBlue")
(set-face-attribute 'mode-line-inactive nil :box nil :background "LightYellow3")
#+end_src

We use [[https://emacs.stackexchange.com/questions/5529/how-to-right-align-some-items-in-the-modeline][this stackoverflow page]] to make left\right aligned stuff.

We use [[https://www.reddit.com/r/emacs/comments/4mhphb/spacemacs_how_to_limit_the_length_of_displayed/][this article]] to try and limit the mode name length.

#+begin_src emacs-lisp
(setq evil-normal-state-tag
    (propertize " NORMAL  " 'face
                (list :background anerenv/evil-color-normal))
    evil-emacs-state-tag
    (propertize " EMACS   " 'face
                (list :background anerenv/evil-color-emacs))
    evil-insert-state-tag
    (propertize " INSERT  " 'face
                (list :background anerenv/evil-color-insert))
    evil-replace-state-tag
    (propertize " REPLACE " 'face
                (list :background anerenv/evil-color-replace))
    evil-motion-state-tag
    (propertize " MOTION  " 'face
                (list :background anerenv/evil-color-motion))
    evil-visual-state-tag
    (propertize " VISUAL  " 'face
                (list :background anerenv/evil-color-visual))
    evil-operator-state-tag
    (propertize " OPERATE " 'face
                (list :background anerenv/evil-color-operate)))

(defun simple-mode-line-render (left right)
  "Return a string of `window-width' length containing LEFT, and RIGHT
 aligned respectively."
  (let* ((available-width (- (window-width) (length left) 2)))
    (format (format " %%s %%%ds " available-width) left right)))

(setq-default mode-line-buffer-identification
    (list -80 (propertized-buffer-identification "%12b")))

(setq-default mode-line-format
    '((:eval (simple-mode-line-render
        ;;Left
        (concat
            (propertize (format-mode-line "%b") 'face '((:foreground "maroon")))
            (format-mode-line " (%m) "))
        ;;Right
        (concat
            (format-mode-line "%5lL%4cC ")
            evil-mode-line-tag)))))
#+end_src

** Window dividers

#+begin_src emacs-lisp
(setq window-divider-default-bottom-width 1
      window-divider-default-places 'bottom-only)

(window-divider-mode 1)
#+end_src

** Tab bar

*** Base

Prettification of tab bar. We only use tab-bar if the version is greater than 27.1.
We also use this section to bind keys.

#+begin_src emacs-lisp
;; If version greater than 27.1

(defun anerenv/new-tab-and-rename ()
    "Created for back compatibility with emacs 27"
    (interactive)
    (progn
        (tab-bar-new-tab)
        (call-interactively 'tab-bar-rename-tab)))

(if (version<= "27.1" emacs-version) (progn
    (tab-bar-mode 1)

    (set-face-attribute 'tab-bar nil
                        :box t
                        :background "LightYellow3"
                        :foreground "DarkSlateGrey"
                        :width 'ultra-expanded
                        :font (anerenv/font-candidate
                               "Iosevka Term" "Consolas")
                        :height 90)

    (set-face-attribute 'tab-bar-tab nil
                        :box '(:color "DarkSlateGrey" :line-width -2)
                        :background "LightYellow3"
                        :weight 'bold)

    (set-face-attribute 'tab-bar-tab-inactive nil
                        :background "LightYellow3"
                        :inherit 'tab-bar)

    (define-key anerenv-global-minor-mode-map
        (kbd "M-<tab>") 'tab-next)
    (define-key anerenv-global-minor-mode-map
        (kbd "M-'") 'tab-previous)
    (define-key anerenv-global-minor-mode-map
        (kbd "M-t r") 'tab-bar-rename-tab)
    (define-key anerenv-global-minor-mode-map
        (kbd "M-t n") 'tab-next)
    (define-key anerenv-global-minor-mode-map
        (kbd "M-t p") 'tab-previous)
    (define-key anerenv-global-minor-mode-map
        (kbd "M-t x") 'tab-bar-close-tab)
    (define-key anerenv-global-minor-mode-map
        (kbd "M-t c") 'anerenv/new-tab-and-rename)
    (setq tab-bar-close-button-show nil
        tab-bar-new-button-show nil
        tab-bar-separator (propertize " ● " 'face
                                      (list :foreground "LightYellow1"
                                            :box '(:color "DarkSlateGrey")))
        )
    (add-hook 'emacs-startup-hook (lambda () (tab-bar-rename-tab "home" 1)))
))
#+end_src

*** Right Group Display

**** Base

#+begin_src emacs-lisp
(defvar anerenv/tab-bar-update-group '()
  "Functions needed to run to update tab bar")

(defvar anerenv/tab-bar-right-group '()
    "A list of items to be displayed on the right of the tab-bar")
#+end_src

**** Battery

#+begin_src emacs-lisp
(defun anerenv/get-bat-stats () "Gets battery statistics. First value returned
is battery percentage, second one is t if charging"
    (let* ((commandout (string-clean-whitespace (shell-command-to-string
        "upower -i /org/freedesktop/UPower/devices/DisplayDevice"))))
        (list
        (string-to-number (progn
            (string-match "\\(?:percentage\\:\s+\\)\\([0-9]+\\)" commandout)
            (match-string 1 commandout)))
        (progn
                    (string-match "\\(?:state\\:\s+\\)\\([^\s]+\\)" commandout)
                    (match-string 1 commandout)))
            ))

(defvar anerenv/bat-string nil "Holds battery string")

(defun anerenv/set-bat-string () "Sets battery-string"
       (let* ((bat-stats (anerenv/get-bat-stats))
              (bat-charge-state (nth 1 bat-stats))
              (bat-percentage-number
                (if (string= bat-charge-state "fully-charged") 100
                    (nth 0 bat-stats)))
              (bat-color (if (<= bat-percentage-number 10) "red3"
                          (if (<= bat-percentage-number 20) "DarkOrange"
                            "DarkSlateGrey")))
              (bat-weight (if (<= bat-percentage-number 20) 'bold 'normal))
              (bat-charge-symbol (if (string= bat-charge-state "charging") "↑"
                    (if (string= bat-charge-state "fully-charged") "◼" "↓"))))
          (setq anerenv/bat-string
             (concat
                "⚡" bat-charge-symbol " "
                (propertize (format "%3d" bat-percentage-number)
                             'face (list :foreground bat-color
                                    :box (list :color "DarkSlateGrey")))))))

(defun anerenv/get-bat-string () "Get battery string"
       (if anerenv/bat-string anerenv/bat-string ""))

(defun anerenv/enable-bat-tab-right-group ()
  "Enables battery display in tab bar"
       (progn
         (cl-pushnew 'anerenv/get-bat-string anerenv/tab-bar-right-group)
         (cl-pushnew 'anerenv/set-bat-string anerenv/tab-bar-update-group)
         ))
#+end_src

**** Clock

#+begin_src emacs-lisp
(defun anerenv/get-tab-bar-time-string () "Get tab bar time string"
       (propertize (format-time-string "%a, %b %d %H:%M")
        'face '(:background "LightYellow3" :foreground "DarkSlateGrey")))

(defun anerenv/enable-clock-tab-right-group ()
  "Enables clock display in tab bar"
         (cl-pushnew 'anerenv/get-tab-bar-time-string
                     anerenv/tab-bar-right-group))
#+end_src

By default let's enable the clock display

#+begin_src emacs-lisp
(anerenv/enable-clock-tab-right-group)
#+end_src

**** Network

Code to check for internet connection:

https://emacs.stackexchange.com/questions/7653/elisp-code-to-check-for-internet-connection

#+begin_src emacs-lisp
(defvar anerenv/network-status-string nil "Holds network status string")

(defun anerenv/get-network-status-string () "Gets the network status string"
       (if anerenv/network-status-string anerenv/network-status-string ""))

(defun anerenv/set-network-string-sentinel (process event)
    "Sets the network string based on proc run"
    (setq anerenv/network-status-string
            (concat
                "↹ "
                (if (= 0 (process-exit-status process))
                    (propertize "✓" 'face
                                (list :foreground "green3"
                                    :background "LightYellow3"
                                    :box (list :color "DarkSlateGrey")))
                    (propertize "X" 'face
                                (list :foreground "red3"
                                    :background "LightYellow3"
                                    :box (list :color "DarkSlateGrey")))))))

(defun anerenv/start-network-test-proc () "Tests whether internet"
       (interactive)
    (set-process-sentinel
        (start-process "wget" nil "wget" "--spider" "--timeout=1"
                       "www.google.com") 'anerenv/set-network-string-sentinel))

(defun anerenv/enable-network-tab-right-group ()
  "Enables network display in tab bar"
       (progn
         (cl-pushnew 'anerenv/get-network-status-string
                     anerenv/tab-bar-right-group)
         (cl-pushnew 'anerenv/start-network-test-proc
                     anerenv/tab-bar-update-group)
         ))
#+end_src

**** Pomodoro

#+begin_src emacs-lisp
(defun anerenv/pomodoro/get-tab-bar-str ()
  "Get string for pomodoro tab bar display"
  (concat "⧖ "
          (let ((currtime (current-time)))
          (if anerenv/pomodoro/current-task
            (concat "✎ " (format-time-string "%M"
                          (time-subtract
                           anerenv/pomodoro/current-work-end-time currtime)))
            (if anerenv/pomodoro/current-rest-end-time
                (concat "⏾ " (format-time-string "%M" (time-subtract
                                anerenv/pomodoro/current-rest-end-time currtime
                                )))
                    (concat "✖ 00"))))))

(defun anerenv/enable-pomodoro-tab-right-group ()
  "Enables clock display in tab bar"
         (cl-pushnew 'anerenv/pomodoro/get-tab-bar-str
                     anerenv/tab-bar-right-group))

(anerenv/enable-pomodoro-tab-right-group)
#+end_src

**** Finalization

#+begin_src emacs-lisp
(defun anerenv/tab-bar-right-group-func ()
  "Function that returns a string to be displayed on right of tab-bar"
  (concat
    tab-bar-separator
    (mapconcat 'eval
              (remove ""
                      (mapcar 'funcall anerenv/tab-bar-right-group))
              tab-bar-separator)
    tab-bar-separator))

(defun anerenv/tab-bar-update-func () "Function to update the tab bar"
       (progn
         (mapc 'funcall anerenv/tab-bar-update-group)
         (force-mode-line-update)))

(defun anerenv/tab-bar-spaces () "Return spacing for beginning of tab bar"
       (propertize "            " 'face '(:background "LightYellow3")))

(if (version<= "28.1" emacs-version) (progn
    (setq tab-bar-format
        '(
        tab-bar-format-history
        tab-bar-format-tabs
        tab-bar-separator
        tab-bar-format-add-tab
        tab-bar-format-align-right
        anerenv/tab-bar-right-group-func))
    (define-key anerenv-global-minor-mode-map
        (kbd "M-n") 'tab-switch)
    (if (member system-type '(gnu gnu/linux))
        (anerenv/run-timer 'tab-timer 'anerenv/tab-bar-update-func 5))
))
#+end_src

** EXWM

We execute the following code only if started with EXWM argument

*** Setup

#+begin_src emacs-lisp
(defun anerenv-load-exwm(switch)
(progn
#+end_src

#+begin_src emacs-lisp
(use-package exwm)
#+end_src

*** Defaults

#+begin_src emacs-lisp
(server-start)
(require 'exwm)
#+end_src

*** Workspaces

#+begin_src emacs-lisp
(setq exwm-workspace-number 4)
(setq exwm-layout-show-all-buffers t)
(setq exwm-workspace-show-all-buffers t)
#+end_src

*** System tray

#+begin_src emacs-lisp
(require 'exwm-systemtray)
(setq exwm-systemtray-background-color "LightYellow3")
(exwm-systemtray-enable)
#+end_src

*** Smart buffer naming

#+begin_src emacs-lisp
(add-hook 'exwm-update-class-hook
          (lambda ()
            (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                        (string-prefix-p "qute" exwm-instance-name)
              (exwm-workspace-rename-buffer exwm-class-name))))

(add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string-prefix-p "qute" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))

(add-hook 'exwm-update-title-hook
        (lambda ()
            (when (or (not exwm-instance-name)
                    (string-prefix-p "mpv" exwm-class-name))
            (exwm-workspace-rename-buffer (concat "mpv | " exwm-title)))))

(add-hook 'exwm-update-class-hook
        (lambda ()
            (when (or (not exwm-instance-name)
                    (string-prefix-p "mpv" exwm-class-name))
            (exwm-workspace-rename-buffer (concat "mpv | " exwm-title)))))

#+end_src

*** Turn off evil

#+begin_src emacs-lisp
(add-to-list 'evil-emacs-state-modes 'exwm-mode)
#+end_src

*** Basic keybindings

Global keybindings can be defined with `exwm-input-global-keys'.
Here are a few examples:
#+begin_src emacs-lisp
(setq exwm-input-global-keys
      `(
        ;; Bind "s-<f2>" to "slock", a simple X display locker.
        ([s-f2] . (lambda ()
            (interactive)
            (start-process "" nil "/usr/bin/slock")))
        ([s-<tab>] . persp-switch)
        ;; Bind "s-r" to exit char-mode and fullscreen mode.
        ([?\s-r] . exwm-reset)
        ;; Bind "s-w" to switch workspace interactively.
        ([?\s-w] . exwm-workspace-switch)
        ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
        ,@(mapcar (lambda (i)
                    `(,(kbd (format "s-%d" i)) .
                      (lambda ()
                        (interactive)
                        (exwm-workspace-switch-create ,i))))
                  (number-sequence 0 9))
        ;; Bind "s-&" to launch applications ('M-&' also works if the output
        ;; buffer does not bother you).
        ([?\s-&] . (lambda (command)
             (interactive (list (read-shell-command "$ ")))
             (start-process-shell-command command nil command)))
        ))

(defun anerenv/take-screenshot ()
  (interactive)
  (shell-command "flameshot gui")
)

(defun anerenv/start-qutebrowser ()
  (interactive)
  (start-process "qutebrowser" nil "qutebrowser")
)

(define-key anerenv-global-minor-mode-open-map
    (kbd "q") 'anerenv/start-qutebrowser)
(define-key anerenv-global-minor-mode-map
  (kbd "<print>") 'anerenv/take-screenshot)
#+end_src

*** RANDR screen settings

Enabling randr. Automatic mapping of randr screens to workspaces.

#+begin_src emacs-lisp
(require 'exwm-randr)

(defun anerenv/re-seq (regexp string)
  "Get a list of all regexp matches in a string"
  (save-match-data
    (let ((pos 0)
          matches)
      (while (string-match regexp string pos)
        (push (match-string 0 string) matches)
        (setq pos (match-end 0)))
      matches)))

(defun anerenv/get-monitor-list ()
    (mapcar (lambda (x) (match-string (string-match "^[A-Za-z]+-*[0-9]+" x) x))
        (anerenv/re-seq "^[A-Za-z]+-*[0-9]+ connected"
                        (shell-command-to-string "xrandr"))))

(defun anerenv/add-indexes (list)
  (anerenv/add-indexes-i list 1)
)

(defun anerenv/add-indexes-i (list i)
  (if list
        (cons i (cons (car list) (anerenv/add-indexes-i (cdr list) (+ i 1))))
        nil))

(defun anerenv/update-exwm-randr-workspace-monitor-plist ()
  (interactive)
    (progn
        (start-process
            "xlayoutdisplay" nil "xlayoutdisplay")
        (setq exwm-randr-workspace-monitor-plist
                (anerenv/add-indexes (anerenv/get-monitor-list)))
        (exwm-randr-refresh))
  )

(add-hook 'exwm-randr-screen-change-hook
            'anerenv/update-exwm-randr-workspace-monitor-plist)

(define-key anerenv-global-minor-mode-map
  (kbd "s-x") 'anerenv/update-exwm-randr-workspace-monitor-plist)
#+end_src

*** Prefix keys

Sending simulated keys to X windows
#+begin_src emacs-lisp
(setq exwm-input-prefix-keys
  '(?\C-x ?\C-u ?\C-h ?\M-x ?\M-& ?\M-: ?\s-d ?\s-m ?\s-r ?\s-s ?\s-q ?\H-l ?\C-w))
#+end_src

*** Desktop environment

#+begin_src emacs-lisp
(use-package desktop-environment)
#+end_src

*** Dunst

#+begin_src emacs-lisp
(anerenv/run-service 'dunst "dunst" nil)
#+end_src

*** Flameshot

#+begin_src emacs-lisp
(anerenv/run-service 'flameshot "flameshot" '())
#+end_src

*** Spotify

First let's run Spotifyd

#+begin_src emacs-lisp
;; (anerenv/run-service 'spotifyd "spotifyd" '("--no-daemon") t)
#+end_src

Then we run smudge. We use this to control

#+begin_src emacs-lisp
;; (use-package smudge
;;   :bind
;;     (:map anerenv-global-minor-mode-open-map
;;         ("s" . 'smudge-command-map)))
#+end_src

We have to set =smudge-oauth2-client-id= and =smudge-oauth2-client-secret= in a seperate file.

*** Media keys

https://gist.github.com/ajyoon/5323b999a01dce8db2d4456da1740fe3

#+begin_src emacs-lisp
(dolist (k '(XF86AudioLowerVolume
             XF86AudioRaiseVolume
             XF86AudioPlay
             XF86AudioStop
             XF86AudioPrev
             XF86AudioNext))
  (push k exwm-input-prefix-keys))

(exwm-input-set-key
    (kbd "<XF86AudioRaiseVolume>")
    (lambda ()
        (interactive) (start-process
            "pactl" nil "pactl" "set-sink-volume" "0" "+5%")))
(exwm-input-set-key
    (kbd "<XF86AudioLowerVolume>")
    (lambda ()
        (interactive) (start-process
            "pactl" nil "pactl" "set-sink-volume" "0" "-5%")))

(exwm-input-set-key
    (kbd "<XF86AudioMute>")
        (lambda ()
            (interactive) (start-process
                "pactl" nil "pactl" "set-sink-mute" "0" "toggle")))

(exwm-input-set-key
    (kbd "<XF86AudioPlay>")
    'desktop-environment-toggle-music)

(exwm-input-set-key
    (kbd "<XF86AudioNext>")
    'desktop-environment-music-next)

(exwm-input-set-key
    (kbd "<XF86AudioPrev>")
    'desktop-environment-music-previous)

(exwm-input-set-key
    (kbd "<XF86AudioStop>")
    'desktop-environment-music-stop)

(exwm-input-set-key
    (kbd "<XF86AudioPause>")
    'desktop-environment-toggle-music)

(exwm-input-set-key
    (kbd "<XF86MonBrightnessUp>")
        (lambda ()
            (interactive) (start-process
                "light" nil "light" "-A" "5")))

(exwm-input-set-key
    (kbd "<XF86MonBrightnessDown>")
        (lambda ()
            (interactive) (start-process
                "light" nil "light" "-U" "5")))
#+end_src

In the event =xbacklight= doesn't work, the following command can be run:

#+begin_example
xrandr --output eDP1 --brightness 0.5
#+end_example

*** Input languages

#+begin_src emacs-lisp
(defun anerenv/enable-heb ()
  (interactive)
    (start-process-shell-command "heb" nil
        "setxkbmap -layout us,il && setxkbmap -option 'grp:alt_shift_toggle'"))
(anerenv/enable-heb)
#+end_src

*** Compositor

Setting frame transparency to 95% for active and inactive frames.

#+begin_src emacs-lisp
;; (set-frame-parameter (selected-frame) 'alpha '(95 . 95))
;; (add-to-list 'default-frame-alist '(alpha . (95 . 95)))
#+end_src

Creating the compositor process.

#+begin_src emacs-lisp
;; (anerenv/run-service
;;     'picom
;;     "picom"
;;     (list "--config" (expand-file-name "~/.config/picom/picom.conf"))
;;     t)
#+end_src

*** Transparency

We do this externally to not deal with function definition problems

We create processes for feh to display wallpaper

#+begin_src emacs-lisp
(defun anerenv/display-background-feh (path)
  "Starts feh to display background from certain path"
  (interactive)
  (anerenv/run-service 'feh "feh"
        (list "--bg-fill" (file-name-as-directory (expand-file-name path))) t))

;; (anerenv/display-background-feh "~/images/wallpapers")
#+end_src

*** Enabling exwm
#+begin_src emacs-lisp
(exwm-randr-enable)
(exwm-enable)
#+end_src

*** Ending

End the execute only if EXWM block.
Close parens, then add to command switch.

#+begin_src emacs-lisp
)) ;Closing off progn for EXWM

(add-to-list 'command-switch-alist '("--start-exwm" . anerenv-load-exwm))
#+end_src

** Clean UI

Disabling the toolbar, the splash-screen, the menu-bar and the scroll-bar
#+begin_src emacs-lisp

(menu-bar-mode -1)   ; no menu bar
(when (display-graphic-p)
    (tool-bar-mode -1)   ; no tool bar with icons
    (scroll-bar-mode -1) ; no scroll bars
    (set-fringe-mode 0))

#+end_src

** Which-Key

#+begin_src emacs-lisp
(use-package which-key
  :config
    (which-key-mode)
)
#+end_src

** Background color

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(background-color . "LightYellow"))
#+end_src

** Fringe color

While we don't actually want fringes (almost at all), some frames use them.

#+begin_src emacs-lisp
(set-face-attribute 'fringe nil :background "LemonChiffon1")
#+end_src

** Easy Prompt

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Minibuff

#+begin_src emacs-lisp
(add-hook 'minibuffer-setup-hook
    (lambda ()
        (make-local-variable 'face-remapping-alist)
        (add-to-list 'face-remapping-alist
                    '(default (:background "WhiteSmoke")))))
#+end_src

** Bell

#+begin_src emacs-lisp
(setq ring-bell-function (lambda () ()))
#+end_src

* Extras

#+begin_src emacs-lisp
(use-package load-dir
  :config (setq load-dirs (concat user-emacs-directory "extra/")))
#+end_src
