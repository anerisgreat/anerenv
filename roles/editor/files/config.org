#+Title: Aner's Emacs Configuration

#+property: header-args :results silent
#+options: toc:2
#+latex_class: article
#+startup: fold

* Base Configuration

** Package installation with straight and use-package

Installation of all required packages.

Straight initialization found [[https://www.github.com/raxod502/straight.el][here]]

#+begin_src emacs-lisp
(setq straight-disable-native-compile t)

(setq comp-deferred-compilation-deny-list nil)

(defvar bootstrap-version)
(let ((bootstrap-file
    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
(with-current-buffer
    (url-retrieve-synchronously
        "https://raw.githubusercontent.com/raxod502/straight.el/master/install.el"
        'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

(setq vc-follow-symlinks t)
#+end_src

Install use-package

Installation of usepackage taken from [[https://github.com/KaratasFurkan/.emacs.d/][KaratasFurkan's generously shared emacs config]].

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+end_src

** Backup files

Taken from [[https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][this post on StackOverflow]]

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . "~/.cache/emacs-backups/"))
      auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))
      backup-by-copying t
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)
#+end_src


Load all the packages that define the work environment.

** Garbage collection

Setting garbage collection to 100M to make it stop freaking out every time I scroll through text.

#+begin_src emacs-lisp

(setq gc-cons-threshold 100000000)

#+end_src

** Keymap setup

Setting of keybindings based on [[https://stackoverflow.com/questions/49853494/the-best-way-to-set-a-key-to-do-nothing][this]]

#+begin_src emacs-lisp

(defun set-window-width (n)
    (adjust-window-trailing-edge (selected-window) ( - n (window-width)) t))

(defun anerenv/open-conf-file ()
    (interactive)
    (find-file (concat user-emacs-directory "config.org"))
    )

;We'll define a basic keymap and already load window-manip funcs

(defvar anerenv-global-minor-mode-map
  (let ((map (make-sparse-keymap)))

    ;Window movement and manipulation
    (define-key map (kbd "M-h") 'windmove-left)
    (define-key map (kbd "M-l") 'windmove-right)
    (define-key map (kbd "M-k") 'windmove-up)
    (define-key map (kbd "M-j") 'windmove-down)

    (define-key map (kbd "M-<left>") 'windmove-left)
    (define-key map (kbd "M-<right>") 'windmove-right)
    (define-key map (kbd "M-<up>") 'windmove-up)
    (define-key map (kbd "M-<down>") 'windmove-down)
    (define-key map (kbd "M-d M-d") 'delete-window)
    (define-key map (kbd "s-d s-d") 'delete-window)
    (define-key map (kbd "M-d D") 'kill-buffer-and-window)
    (define-key map (kbd "M-\\") 'split-window-horizontally)
    (define-key map (kbd "M-\-") 'split-window-vertically)
    (define-key map (kbd "M-d R") (lambda () (interactive)
                    (set-window-width 85)))
    map)
  "anerenv-global-minor-mode keymap.")

(define-minor-mode anerenv-global-minor-mode
  "A minor mode for anerenv global keymaps."
  :init-value t
  :lighter "anerenv")

(anerenv-global-minor-mode 1)

#+end_src

This keymap will be referenced many times during this document at relevant points.

Keymaps are included with relevant sections.

** EVIL mode

Using evil mode.

Unbinding C-w taken from https://stackoverflow.com/questions/24988406/unbinding-evils-c-w-mappings

Redo taken from https://github.com/syl20bnr/spacemacs/issues/14036

#+begin_src emacs-lisp
(setq evil-want-keybinding nil)

(use-package evil
  :init
  (setq evil-want-C-i-jump nil)
  :config
  (require 'evil )
  (evil-mode 1)
  (eval-after-load "evil-maps"
  (dolist (map '(evil-motion-state-map
                 evil-insert-state-map
                 evil-emacs-state-map))
    (define-key (eval map) "\C-w" nil)))

  :bind
  (:map anerenv-global-minor-mode-map
        ("M-w h" . evil-window-decreace-width)
        ("M-w l" . evil-window-increase-width)
        ("M-w k" . evil-window-decrease-height)
        ("M-w j" . evil-window-increase-height))
)

(use-package evil-collection
  :config
  (setq evil-collection-setup-minibuffer t)
)

(use-package undo-tree
  :config
    (evil-set-undo-system 'undo-tree)
    (global-undo-tree-mode 1)
)
#+end_src

Taken from: https://github.com/emacs-evil/evil/issues/1288

Meant to fix indentation for tabs in source blocks.

#+begin_src emacs-lisp

(defun evil-org-insert-state-in-edit-buffer (fun &rest args)
  "Bind `evil-default-state' to `insert' before calling FUN with ARGS."
  (let ((evil-default-state 'insert)
        ;; Force insert state
        evil-emacs-state-modes
        evil-normal-state-modes
        evil-motion-state-modes
        evil-visual-state-modes
        evil-operator-state-modes
        evil-replace-state-modes)
    (apply fun args)
    (evil-refresh-cursor)))

(advice-add 'org-babel-do-key-sequence-in-edit-buffer
            :around #'evil-org-insert-state-in-edit-buffer)

#+end_src

** IVY

Enabling IVY. Taken from [[https://github.com/abo-abo/swiper][their website]].

#+begin_src emacs-lisp
(use-package ivy
  :custom
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    (ivy-count-format "(%d/%d) ")
  :config
    (ivy-mode 1)
)

(use-package ivy-hydra
  :after ivy)
(use-package ivy-avy
  :after ivy)
(use-package counsel
  :after ivy

  :bind
  (:map anerenv-global-minor-mode-map
        ("M-i" . counsel-imenu)
        ("M-b" . counsel-switch-buffer)
        ("C-x C-f" . counsel-find-file))
  )

(use-package swiper
  :after ivy

  :bind
  (:map anerenv-global-minor-mode-map
        ("C-s" . swiper-isearch))
  (:map evil-motion-state-map
        ("/" . swiper-isearch))
  )

#+end_src

*** Keymaps

#+begin_src emacs-lisp
(evil-collection-ivy-setup)
#+end_src

** Projectile

#+begin_src emacs-lisp
(use-package projectile
  :config
    (projectile-mode +1)
    (setq projectile-mode-line-function (lambda () ""))
  :bind
    (:map projectile-command-map
          ("a" . projectile-add-known-project)
    )
    (:map anerenv-global-minor-mode-map
          ("M-p" . projectile-command-map))
)
#+end_src

Ivy for projectile:
Parts taken from [[https://emacs.stackexchange.com/questions/40787/display-corresponding-key-binding-of-command-during-m-x-completion][this post]] and [[https://emacs.stackexchange.com/questions/38841/counsel-m-x-always-shows][this post]] from StackOverflow.

#+begin_src emacs-lisp
(use-package counsel-projectile
  :config
    (counsel-projectile-mode +1)
    (setq projectile-completion-system 'ivy)
    ;Making counsel start with empty regex
    (when (commandp 'counsel-M-x)
        (global-set-key [remap execute-extended-command] 'counsel-M-x))
    (setcdr (assoc 'counsel-M-x ivy-initial-inputs-alist) "")
)
#+end_src

** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :straight (:type built-in)
  :custom
    (tramp-verbose 6)
)

(use-package counsel-tramp)
#+end_src

** YASnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :config
    (yas-global-mode 1)
)
#+end_src

** Flycheck

Must set up

#+begin_src emacs-lisp
(use-package flycheck
  :config
    (global-flycheck-mode 1)
)
#+end_src

** Window dividers

#+begin_src emacs-lisp
(setq window-divider-default-bottom-width 1
      window-divider-default-places 'bottom-only)

(window-divider-mode 1)
#+end_src
** Modeline

Setting colors
#+begin_src emacs-lisp
(set-face-attribute 'mode-line nil :box nil :background "LightBlue2")
(set-face-attribute 'mode-line-inactive nil :box nil :background "LightYellow3")
#+end_src

We use [[https://emacs.stackexchange.com/questions/5529/how-to-right-align-some-items-in-the-modeline][this stackoverflow page]] to make left\right aligned stuff.

We use [[https://www.reddit.com/r/emacs/comments/4mhphb/spacemacs_how_to_limit_the_length_of_displayed/][this article]] to try and limit the mode name length.

#+begin_src emacs-lisp
(setq evil-normal-state-tag
    (propertize " NORMAL  " 'face '((:background "DarkGoldenrod2" :foreground "black")))
    evil-emacs-state-tag
    (propertize " EMACS   " 'face '((:background "SkyBlue2" :foreground "black")))
    evil-insert-state-tag
    (propertize " INSERT  " 'face '((:background "chartreuse3" :foreground "black")))
    evil-replace-state-tag
    (propertize " REPLACE " 'face '((:background "chocolate" :foreground "black")))
    evil-motion-state-tag
    (propertize " MOTION  " 'face '((:background "plum3" :foreground "black")))
    evil-visual-state-tag
    (propertize " VISUAL  " 'face '((:background "gray" :foreground "black")))
    evil-operator-state-tag
    (propertize " OPERATE " 'face '((:background "sandy brown" :foreground "black"))))



(defun simple-mode-line-render (left right)
  "Return a string of `window-width' length containing LEFT, and RIGHT
 aligned respectively."
  (let* ((available-width (- (window-width) (length left) 2)))
    (format (format " %%s %%%ds " available-width) left right)))

(setq-default mode-line-buffer-identification
    (list -80 (propertized-buffer-identification "%12b")))

(setq-default mode-line-format
    '((:eval (simple-mode-line-render
        ;;Left
        (concat
            (propertize (format-mode-line "%b") 'face '((:foreground "maroon")))
            (format-mode-line " (%m) "))
        ;;Right
        (concat
            (format-mode-line "%5lL%4cC ")
            evil-mode-line-tag)))))
#+end_src

* Text

** Text font

Setting font size to 10. The value to place is font-size * 10

#+begin_src emacs-lisp
  (defun anerenv/check-if-font-exists (font)
      "Check if font exists"
      (if (null (x-list-fonts font)) nil t))

  (if (anerenv/check-if-font-exists "LiberationMono")
      (progn
        (set-face-attribute 'default nil :font "LiberationMono")
        (set-face-attribute 'fixed-pitch nil :font "LiberationMono")
      )
  )

  (if (anerenv/check-if-font-exists "Liberation Sans")
      (set-face-attribute 'variable-pitch nil :font "Liberation Sans"))

  (set-face-attribute 'default nil :height 100)
  (set-face-attribute 'variable-pitch nil
       :height 120
       :weight 'normal
       :width 'normal)

  (set-face-attribute 'fixed-pitch nil
       :height 100
       :weight 'normal
       :width 'normal)
#+end_src

** Line numbering

Taken from [[https://www.emacswiki.org/emacs/LineNumbers][this wiki entry]].

#+begin_src emacs-lisp

;; Getting rid of linum on terminal type buffers
(use-package display-line-numbers
    :init
        (defcustom display-line-numbers-exempt-modes
            '(vterm-mode
              eshell-mode
              shell-mode
              term-mode
              ansi-term-mode
              magit-mode
              magit-diff-mode
              notmuch-hello
              pdf-view-mode)
            "Major modes on which to disable the linum mode, exempts them from global requirement"
            :group 'display-line-numbers
            :type 'list
            :version "green")

        (define-global-minor-mode anerenv/global-linum-mode display-line-numbers-mode
            (lambda () (if (and
                (not (apply 'derived-mode-p display-line-numbers-exempt-modes))
                (not (minibufferp)))
            (display-line-numbers-mode))))

        (setq display-line-numbers-type 'visual
            display-line-numbers-grow-only 1
            display-line-numbers-width-start 1)

    :config
        (anerenv/global-linum-mode 1)
        (set-face-attribute 'line-number nil :family (face-attribute 'fixed-pitch :family))
)


#+end_src

** Line highlight

Highlighting lines.

#+begin_src emacs-lisp
(global-hl-line-mode)
#+end_src

** Line wrap

#+begin_src emacs-lisp
(global-visual-line-mode t)
#+end_src

** Parenthesis

Highlight matching parenthesis

#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

** Tabs

Using spaces, default offset is 4.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4
              c-basic-offset 4
              tab-always-indent 'complete)
#+end_src

** BIDI and lang

Setting up Hebrew as alternative input, using bidi mode so that every line is
aligned left\right accordingly.

#+begin_src emacs-lisp
(setq-default default-input-method "hebrew"
              bidi-display-reordering t
              bidi-paragraph-direction 'nil)

(defun anerenv/set-bidi-env ()
    (setq bidi-paragraph-direction 'nil)
)

(define-key anerenv-global-minor-mode-map
    (kbd "C-SPC") 'toggle-input-method)
#+end_src

** Whitespace mode

We define a custom global-whitespace-mode in order to enable it only on relevant modes.

We check if the current mode doesn't derive from a set of blacklisted mode, the main
culprit being terminal modes where whitespace occur naturally and are a pain to see all
the time.

#+begin_src emacs-lisp
(setq-default whitespace-style
      '(face tabs trailing tab-mark
             lines-tail indentation))

(defun anerenv/whitespace-mode-func ()
  (interactive)
    (if (derived-mode-p 'text-mode 'prog-mode 'org-mode)
        (whitespace-mode 1) (whitespace-mode -1)))

#+end_src
#+begin_src emacs-lisp
(add-hook 'change-major-mode-hook 'anerenv/whitespace-mode-func)
#+end_src

** Irony-mode

Must work on this. While it does work, can get slow and for weird projects can show errors.

#+begin_src emacs-lisp
;; == irony-mode ==
(use-package irony
  :ensure t
  :defer t
  :init
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)
  :config
  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))
  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  )

#+end_src

** Company mode

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :defer t
  :init (add-hook 'after-init-hook 'global-company-mode)
  :config
  (use-package company-irony :ensure t :defer t)
  (setq
        company-minimum-prefix-length   2
        company-show-numbers            t
        company-tooltip-limit           20
        company-idle-delay              0.2
  )
  :bind ("C-;" . company-complete-common)
  :hook (irony-mode . company-mode)
  )
#+end_src

** Flycheck

#+begin_src emacs-lisp
(use-package flycheck-irony
  :after flycheck
  :config
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)
    (add-hook 'c++-mode-hook (lambda () (setq flycheck-checker 'irony)))
)
#+end_src

** HTMLize

#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

** Folding

Using Hideshow

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** Emojis!

#+begin_src emacs-lisp
(use-package emojify
  :hook (after-init . global-emojify-mode))
#+end_src

:smile:

* Major modes

** Magit

#+begin_src emacs-lisp
(use-package magit
  :config
    (evil-collection-magit-setup)
)
#+end_src

** VTerm

#+begin_src emacs-lisp
(use-package vterm
  :config
  (add-hook 'vterm-mode-hook
            (lambda () (setq-local global-hl-line-mode nil)))
)

#+end_src

** Eshell
Watch based on https://emacs.stackexchange.com/questions/44389/how-to-watch-and-cat-and-grep-with-emacs

#+begin_src emacs-lisp
(use-package eshell
  :straight (:type built-in)

  :config
    (add-hook 'eshell-mode-hook (company-mode -1))
)

(defvar watch-history nil)
(defun eshell/watch (command &optional name)
    "Runs \"watch COMMAND\" in a `term' buffer.  \"q\" to exit."
    (interactive
    (list (read-from-minibuffer "watch " nil nil nil 'watch-history)))
    (let* ((name (or name (concat "watch " command)))
            (switches (split-string-and-unquote command))
            (termbuf (apply 'make-term name "watch" nil switches))
            (proc (get-buffer-process termbuf)))
        (set-buffer termbuf)
        (term-mode)
        (term-char-mode)
        (setq-local show-trailing-whitespace nil)
        ;; Kill the process interactively with "q".
        (set-process-query-on-exit-flag proc nil)
        (let ((map (make-sparse-keymap))
            (cmdquit (make-symbol "watch-quit")))
        (put cmdquit 'function-documentation "Kill the `watch' buffer.")
        (put cmdquit 'interactive-form '(interactive))
        (fset cmdquit (apply-partially 'kill-process proc))
        (set-keymap-parent map (current-local-map))
        (define-key map (kbd "q") cmdquit)
        (use-local-map map))
        ;; Kill the buffer automatically when the process is killed.
        (set-process-sentinel
        proc (lambda (process signal)
                (and (memq (process-status process) '(exit signal))
                    (buffer-live-p (process-buffer process))
                    (kill-buffer (process-buffer process)))))
        ;; Display the buffer.
        (switch-to-buffer termbuf)))

#+end_src

** PDF-Tools

For viewing PDF files and such!
Broken for the time being
#+begin_src emacs-lisp
(use-package pdf-tools
  :config
    (pdf-tools-install)
    (add-hook 'pdf-view-mode-hook
        (lambda () (blink-cursor-mode 0)))

    (evil-collection-pdf-setup)
)


#+end_src

*** Stop the blinking on PDF-View-Mode

Taken from [[https://github.com/munen/emacs.d/blob/master/configuration.org][Munen's configuration on GitHub]].
When using evil-mode and pdf-tools and looking at a zoomed PDF, it will blink, because the cursor blinks.
This configuration disables this whilst retaining the blinking cursor in other modes.
Disabled for now
#+begin_src emacs-lisp
;(evil-set-initial-state 'pdf-view-mode 'emacs)
;(add-hook 'pdf-view-mode-hook
;  (lambda ()
;    (set (make-local-variable 'evil-emacs-state-cursor) (list nil))))
#+end_src

** ORG

All things org!

Setting fixed fonts in org-mode so that mixed type works as intended.

#+begin_src emacs-lisp
(defun set-org-mode-fixed-pitch-faces ()
    (mapc (lambda (face) (set-face-attribute face nil
                :font (face-attribute 'fixed-pitch :font)
                :height (face-attribute 'fixed-pitch :height)))
    `(line-number
        org-block
        org-special-keyword
        org-drawer
        org-todo
        org-done
        org-priority
        org-checkbox
        org-block-end-line
        org-block-begin-line
        org-table org-verbatim)))

(use-package org
    :straight
        (:type built-in)
    :hook
        (org-mode . variable-pitch-mode)
    :config
        (set-org-mode-fixed-pitch-faces)
        (add-hook 'org-mode-hook 'anerenv/set-bidi-env)
        (add-hook 'org-mode-hook (lambda ()
            (setq-local whitespace-style '(face tabs trailing tab-mark
            indentation))))
        (setq org-src-tab-acts-natively t)
        (setq org-adapt-indentation nil)
        (setq org-startup-folded 'folded)
        (set-face-attribute 'org-code nil
            :family (face-attribute 'fixed-pitch :family))
        (set-face-attribute 'org-block nil
            :family (face-attribute 'fixed-pitch :family))
)
#+end_src

*** Agenda

#+begin_src emacs-lisp
(setq org-agenda-files (list "~/.tasks"))
(setq org-default-notes-file "~/.tasks/tasks.org")
#+end_src

*** Babel

Define languages to use

#+begin_src emacs-lisp
(require 'ob)
(require 'ob-tangle)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (emacs-lisp . t)
   (python . t)
   (org . t)
   (lilypond . t)
   (latex . t)
   (js . t)
   (java . t)
   (dot . t)
   (C . t)))

(add-to-list 'org-src-lang-modes (quote ("dot". graphviz-dot)))
(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
(add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))
#+end_src

*** Code blocks

The following displays the contents of code blocks in Org-mode files using
the major-mode of the code. It also changes the behavior of TAB to as if it
were used in the appropriate major mode.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation t)
#+end_src

*** PDF exporting

#+begin_src emacs-lisp
(setq org-latex-listings 'minted)
(setq org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(require 'ox-latex)
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))
#+end_src

Creating classes

#+begin_src emacs-lisp
(setq org-latex-classes
     '(
        ("article"
"\\documentclass{article}
[DEFAULT-PACKAGES]
\\usepackage{polyglossia}
\\usepackage[cache=false]{minted}
\\usepackage{xcolor}
\\usepackage{indentfirst}
\\usepackage{amsfonts}
\\usepackage{amsmath}
\\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\\setdefaultlanguage{english}
\\setlength{\\parindent}{0in}

\\setminted{
    bgcolor=codebg,
    breaklines=true,
    mathescape,
    fontsize=\\scriptsize,
    linenos=false,
}
\\newfontfamily\\hebrewfont{LiberationSans}[Script=Hebrew]
\\setotherlanguage{hebrew}
"
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}" . "\\paragraph*{%s}")
            ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
        )
      )
    )

(setq org-export-with-toc nil
      org-export-with-section-numbers nil)
#+end_src

This should render Hebrew text.

#+begin_export latex
\begin{hebrew}
#+end_export
זה אמור לעבוד
#+begin_export latex
\end{hebrew}
#+end_export

*** Org block highlighting

#+begin_src emacs-lisp
(use-package color)
#+end_src

*** Python version

#+begin_src emacs-lisp
(setq org-babel-python-command "python3")
#+end_src

*** Async blocks

#+begin_src emacs-lisp
(use-package ob-async
  :config
    ;Setting command of async blocks to Python3
    (add-hook 'ob-async-pre-execute-src-block-hook
            '(lambda ()
            (setq org-babel-python-command "python3")
    ))
)
#+end_src

*** Inline images

#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)

(defun shk-fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(with-eval-after-load 'org
  (add-hook 'org-babel-after-execute-hook 'shk-fix-inline-images))
#+end_src

*** Sticky headers

#+begin_src emacs-lisp

;; (use-package org-sticky-header
;;   :config
;;         (add-hook 'org-mode-hook (lambda () (org-sticky-header-mode)))
;;    )

#+end_src

*** Snippets

Want to create snippets for latex insertion.
There is one template for inline and one template for standalone latex snippets.
Each template is defind by two templates. One for other langauges and one for standard
input. This is done to toggle back to the original language once done with the
function toggle-input-method.

#+begin_src emacs-lisp

(defun dumb-toggle-input-method ()
    (if current-input-method (toggle-input-method))
)
;Inline
(yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\$$1\$$0"
                                      "ORG_LATEX_INLINE_SNIPPET_ENG"
                                      '(not (eval current-input-method))
                                      nil
                                      nil
                                      nil
                                      "C-l"
                                      nil
                                      nil
                                      )))

(yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\$$1\$$0"
                                      "ORG_LATEX_INLINE_SNIPPET_OTHER_LANG"
                                      '(eval current-input-method)
                                      nil
                                      '((unused (dumb-toggle-input-method))
                                        (yas-after-exit-snippet-hook 'toggle-input-method))
                                      nil
                                      "C-l"
                                      nil
                                      nil
                                      )))

;Not inline
(yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\n\n\$\$$1\$\$\n\n$0"
                                      "ORG_LATEX_OUTLINE_SNIPPET_ENG"
                                      '(not (eval current-input-method))
                                      nil
                                      nil
                                      nil
                                      "C-S-l"
                                      nil
                                      nil
                                      )))
(yas-define-snippets 'org-mode (list (list
                                      nil
                                      "\n\n\$\$$1\$\$\n\n$0"
                                      "ORG_LATEX_OUTLINE_SNIPPET_OTHER_LANG"
                                      '(eval current-input-method)
                                      nil
                                      '((unused (dumb-toggle-input-method))
                                        (yas-after-exit-snippet-hook 'toggle-input-method))
                                      nil
                                      "C-S-l"
                                      nil
                                      nil
)))
#+end_src

Snippet for src blocks

#+begin_src emacs-lisp
(yas-define-snippets 'org-mode (list (list
                                      nil
                                      "#+begin_src $1\n$0\n\n#+end_src"
                                      "ORG_SRC_BLOCK"
                                      nil
                                      nil
                                      nil
                                      nil
                                      "C-c i b"
                                      nil
                                      nil
)))

(yas-define-snippets 'org-mode (list (list
                                      nil
                                      "#+begin_export latex\n\\begin{english}\n#+end_export\n#+begin_src $1\n$0\n\n#+end_src\n#+begin_export latex\n\\end{english}\n#+end_export"
                                      "ORG_SRC_ENGLISH_BLOCK"
                                      nil
                                      nil
                                      nil
                                      nil
                                      "C-c i B"
                                      nil
                                      nil
)))


#+end_src

*** Tree slide
#+begin_src emacs-lisp
(use-package org-tree-slide
    :config
    (setq org-tree-slide-slide-in-effect nil))
#+end_src
*** Useful to remember

To preview latex fragment as image embedded in text
#+begin_example
org-toggle-latex-fragment
#+end_example

*** Binding

#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-a") nil)
(define-key org-mode-map (kbd "C-a l") 'org-toggle-latex-fragment)
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode)
#+end_src

** CMake

#+begin_src emacs-lisp
(use-package cmake-mode)
#+end_src

** Racket

#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** Typescript

#+begin_src emacs-lisp
(use-package typescript-mode)
#+end_src

** Mail

Due to the fact that setting up email in general is complicated, I'll recap the process here.

Before ANYTHING, setup pass.

https://wiki.archlinux.org/title/Pass

Initialize password

Then for gmail, used

#+begin_src bash :results none :exports code
pass init <ID>
pass insert gmail.com/<username>
#+end_src

It prompted for password, I put it in.

Then setup mbsync properly. The ansible files already take care of that.

Then we setup ~/.mbsyncrc. This file is important and is not linked to repository for security reasons.

https://wiki.archlinux.org/title/isync

Wrote mbsyncrc

Created all directories

Went into gmail settings to allow less secure things.

https://notmuchmail.org/getting-started/

We then RUN notmuch, and notmuch setup for prompt.

Adding emails can be done with notmuch new

#+begin_src emacs-lisp
(use-package notmuch
  :straight (:type built-in)
  :init
    (setq-default
        notmuch-hello-sections
            '(notmuch-hello-insert-saved-searches
              notmuch-hello-insert-alltags)
        notmuch-search-oldest-first nil
        notmuch-always-prompt-for-sender t
        message-sendmail-envelope-from 'header)
    (defun anerenv/sync-mail-notify ()
        (interactive)
        (setq sync-mail-process
            (start-process-shell-command
             "mailsync"
             "*mailsync*"
             "{ mbsync -a && { if [[ $(notmuch new | grep \"No new mail\") ]]; then dunstify -u low \"Synced mail\" ; else dunstify \"New mail!\" ; fi ; } ; } || dunstify -u critical \"Error syncing mail\"")))
    (defun anerenv/sync-mail-n-notify ()
        (interactive)
        (setq sync-mail-process
            (start-process-shell-command
             "mailsync"
             "*mailsync*"
             "{ mbsync -a && { if [[ $(notmuch new | grep \"No new mail\") ]]; then : ; else dunstify \"New mail!\" ; fi ; } ; }")))
    (defun anerenv/emacs-notmuch-face ()
        (face-remap-add-relative 'default '(:inherit 'variable-pitch))
        )

  :config
    (evil-collection-notmuch-setup)
    (run-with-timer 0 (* 60 10) 'anerenv/sync-mail-n-notify)
    (add-hook 'notmuch-show-mode 'anerenv/emacs-notmuch-face)
    (setq send-mail-function 'sendmail-send-it)
)
#+end_src

Run this command to make sendmail use the right thing

#+begin_src bash :results none :exports code
sudo ln -s /usr/bin/msmtp /usr/sbin/sendmail
#+end_src

Then we go to

https://wiki.archlinux.org/title/isync

We will do this manually.

** LEETCODE

#+begin_src emacs-lisp
(require 'subr-x)

(use-package leetcode)
#+end_src

** Proced

#+begin_src emacs-lisp
(evil-collection-proced-setup)
#+end_src

** Elfeed

MPV from https://www.reddit.com/r/emacs/comments/7usz5q/youtube_subscriptions_using_elfeed_mpv_no_browser/

https://medium.com/emacs/using-elfeed-to-view-videos-6dfc798e51e6

#+begin_src emacs-lisp
(defun load-ytsublist-channels ()
    "Loads into elfeed-feeds all channels from ~/.config/ytsubs-channels"
    (if (file-exists-p "~/.config/ytsubs-channels")
        (dolist
            (yt-id (split-string
            (slurp "~/.config/ytsubs-channels") "\n" t))
            (add-to-list 'elfeed-feeds
                (concat
                "https://www.youtube.com/feeds/videos.xml?channel_id="
                    yt-id)))))

(defun load-ytsublist-users ()
    "Loads into elfeed-feeds all users from ~/.config/ytsubs-users"
    (if (file-exists-p "~/.config/ytsubs-users")
        (dolist
            (yt-id (split-string
            (slurp "~/.config/ytsubs-users") "\n" t))
            (add-to-list 'elfeed-feeds
                (concat
                    "https://www.youtube.com/feeds/videos.xml?user="
                    yt-id)))))

(use-package elfeed
    :init
        (defun elfeed-v-mpv (url)
            "Watch a video from URL in MPV"
            (start-process-shell-command "mpv" nil (concat "mpv " url)))

        (defun elfeed-view-mpv (&optional use-generic-p)
        "Youtube-feed link"
        (interactive "P")
        (let ((entries (elfeed-search-selected)))
            (cl-loop for entry in entries
            do (elfeed-untag entry 'unread)
            when (elfeed-entry-link entry)
            do (elfeed-v-mpv it))
        (mapc #'elfeed-search-update-entry entries)))


        (defun slurp (f)
        (with-temp-buffer
            (insert-file-contents f)
            (buffer-substring-no-properties
            (point-min)
            (point-max))))

        (setq-default elfeed-search-filter "@3-days-ago")
    :config
        (define-key elfeed-search-mode-map (kbd "C-c v") 'elfeed-view-mpv)
        (evil-collection-elfeed-setup)
        (load-ytsublist-channels)
        (load-ytsublist-users)
)
#+end_src

** Pass

#+begin_src emacs-lisp
(use-package pass)
#+end_src

** Chess
#+begin_src emacs-lisp

(use-package chess
  :config
  (setq chess-images-separate-frame nil
        chess-images-default-size 60
        chess-images-dark-color "LightYellow3"
        chess-images-light-color "LightYellow2"
        chess-images-white-color "gray100"
        chess-images-black-color "gray10")
  (add-to-list 'evil-emacs-state-modes 'chess-display-mode)
  (advice-add 'chess-display-mode :before '(lambda () (setq-local global-hl-line-mode nil)))
)

#+end_src
** Ibuffer

#+begin_src emacs-lisp

(evil-collection-ibuffer-setup)
(define-key anerenv-global-minor-mode-map
    (kbd "C-x C-b") 'ibuffer)

#+end_src

** Wiki-summary
#+begin_src emacs-lisp
(use-package wiki-summary)
#+end_src
** Dashboard
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
(use-package dashboard
    :config
    (add-hook 'after-init-hook
        (lambda () (dashboard-insert-startupify-lists)))
    (add-hook 'emacs-startup-hook (lambda ()
        (switch-to-buffer dashboard-buffer-name)
        (goto-char (point-min))
        (redisplay)
        (run-hooks 'dashboard-after-initialize-hook)))
    (add-to-list 'evil-emacs-state-modes 'dashboard-mode)
    (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (projects . 5)
                        (agenda . 5))
          dashboard-center-content t
          dashboard-set-init-info nil
          dashboard-set-footer nil
          dashboard-startup-banner nil)
    ;; (defun anerenv/stupid-func () (message "Cheese whiz!"))
    ;; (defun dashboard-insert-custom (list-size)
    ;;     (insert "Custom text"))
    ;; (add-to-list 'dashboard-item-generators  '(anerenv/stupid-func . dashboard-insert-custom))
    ;; (add-to-list 'dashboard-items '(anerenv/stupid-func) t)

)
#+end_src
** Calendar
#+begin_src emacs-lisp
(evil-collection-calendar-setup)
#+end_src

* UI
** Perspective

#+begin_src emacs-lisp
(use-package perspective
   :config
     (persp-mode 1)
     (setq persp-show-modestring 'nil)
   :bind (:map anerenv-global-minor-mode-map
              ("M-<tab>" . persp-next)
              ("M-n" . persp-switch)
              ("M-`" . persp-prev)
              ))

(use-package persp-projectile
  :bind(:map projectile-command-map
    ("p" . projectile-persp-switch-project)
  )
)
#+end_src

** EXWM
We execute the following code only if started with EXWM argument

*** Setup

#+begin_src emacs-lisp
(defun anerenv-load-exwm(switch)
(progn
#+end_src

#+begin_src emacs-lisp
(use-package exwm)
#+end_src

*** Defaults

#+begin_src emacs-lisp
(server-start)
(require 'exwm)
#+end_src

*** Workspaces

#+begin_src emacs-lisp
(setq exwm-workspace-number 4)
(setq exwm-layout-show-all-buffers t)
(setq exwm-workspace-show-all-buffers t)
#+end_src

*** Smart buffer naming

#+begin_src emacs-lisp
(add-hook 'exwm-update-class-hook
          (lambda ()
            (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                        (string-prefix-p "qute" exwm-instance-name)
              (exwm-workspace-rename-buffer exwm-class-name))))

(add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string-prefix-p "qute" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))

(add-hook 'exwm-update-title-hook
        (lambda ()
            (when (or (not exwm-instance-name)
                    (string-prefix-p "mpv" exwm-class-name))
            (exwm-workspace-rename-buffer (concat "mpv | " exwm-title)))))

(add-hook 'exwm-update-class-hook
        (lambda ()
            (when (or (not exwm-instance-name)
                    (string-prefix-p "mpv" exwm-class-name))
            (exwm-workspace-rename-buffer (concat "mpv | " exwm-title)))))

#+end_src

*** Turn off evil
#+begin_src emacs-lisp
(add-to-list 'evil-emacs-state-modes 'exwm-mode)
#+end_src
*** Basic keybindings

Global keybindings can be defined with `exwm-input-global-keys'.
Here are a few examples:
#+begin_src emacs-lisp
(setq exwm-input-global-keys
      `(
        ;; Bind "s-<f2>" to "slock", a simple X display locker.
        ([s-f2] . (lambda ()
            (interactive)
            (start-process "" nil "/usr/bin/slock")))
        ([s-<tab>] . persp-switch)
        ;; Bind "s-r" to exit char-mode and fullscreen mode.
        ([?\s-r] . exwm-reset)
        ;; Bind "s-w" to switch workspace interactively.
        ([?\s-w] . exwm-workspace-switch)
        ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
        ,@(mapcar (lambda (i)
                    `(,(kbd (format "s-%d" i)) .
                      (lambda ()
                        (interactive)
                        (exwm-workspace-switch-create ,i))))
                  (number-sequence 0 9))
        ;; Bind "s-&" to launch applications ('M-&' also works if the output
        ;; buffer does not bother you).
        ([?\s-&] . (lambda (command)
             (interactive (list (read-shell-command "$ ")))
             (start-process-shell-command command nil command)))
        ))

(defun anerenv/take-screenshot ()
  (interactive)
  (shell-command "flameshot gui")
)

(defun anerenv/start-qutebrowser ()
  (interactive)
  (start-process-shell-command "qutebrowser" nil "qutebrowser")
)

(define-key anerenv-global-minor-mode-map
    (kbd "s-o c") 'anerenv/open-conf-file)
(define-key anerenv-global-minor-mode-map
    (kbd "s-o q") 'anerenv/start-qutebrowser)
(define-key anerenv-global-minor-mode-map
    (kbd "s-o p") 'run-python)
(define-key anerenv-global-minor-mode-map
  (kbd "<print>") 'anerenv/take-screenshot)
#+end_src

*** RANDR screen settings

Enabling randr

Partially from [[https://github.com/ch11ng/exwm/issues/202][here]]. (All commented out now)

#+begin_src emacs-lisp
(require 'exwm-randr)

(defun anerenv/re-seq (regexp string)
  "Get a list of all regexp matches in a string"
  (save-match-data
    (let ((pos 0)
          matches)
      (while (string-match regexp string pos)
        (push (match-string 0 string) matches)
        (setq pos (match-end 0)))
      matches)))

(defun anerenv/get-monitor-list ()
    (mapcar (lambda (x) (match-string (string-match "^[A-Za-z]+-*[0-9]+" x) x))
        (anerenv/re-seq "^[A-Za-z]+-*[0-9]+ connected" (shell-command-to-string "xrandr"))))

(defun anerenv/add-indexes (list)
  (anerenv/add-indexes-i list 1)
)


(defun anerenv/add-indexes-i (list i)
  (if list
        (cons i (cons (car list) (anerenv/add-indexes-i (cdr list) (+ i 1))))
        nil))

(defun anerenv/update-exwm-randr-workspace-monitor-plist ()
  (interactive)
    (progn
        (start-process-shell-command
        "xlayoutdisplay" nil "xlayoutdisplay")
        (setq exwm-randr-workspace-monitor-plist
                (anerenv/add-indexes (anerenv/get-monitor-list)))
        (exwm-randr-refresh))
  )

(add-hook 'exwm-randr-screen-change-hook
            'anerenv/update-exwm-randr-workspace-monitor-plist)

(define-key anerenv-global-minor-mode-map
  (kbd "s-o x") 'anerenv/update-exwm-randr-workspace-monitor-plist)
#+end_src

Enabling exwm
#+begin_src emacs-lisp
(exwm-randr-enable)
(exwm-enable)
#+end_src

*** Prefix keys

Sending simulated keys to X windows
#+begin_src emacs-lisp
(setq exwm-input-prefix-keys
  '(?\C-x ?\C-u ?\C-h ?\M-x ?\M-& ?\M-: ?\s-d ?\s-m ?\s-r ?\s-s ?\s-q ?\H-l ?\C-w))
#+end_src

*** Desktop environment

#+begin_src emacs-lisp
(use-package desktop-environment)
#+end_src

*** Polybar

#+begin_src emacs-lisp
(defvar anerenv/polybar-process nil
  "Holds the process of the running Polybar instance, if any")

(defvar anerenv/last-persp-name nil
  "Name of last active persp")

(defun anerenv/kill-panel ()
  (interactive)
  (when anerenv/polybar-process
    (ignore-errors
      (kill-process anerenv/polybar-process)))
  (setq anerenv/polybar-process nil))

(defun anerenv/start-panel ()
  (interactive)
  (progn
    (anerenv/kill-panel)
    (setq anerenv/polybar-process
        (start-process-shell-command "polybar" nil
            (concat "polybar -c "
            (concat (expand-file-name "~/.config/emacs/lazymacs/polybar-config")
                " exwm-bar"))))
    (set-process-query-on-exit-flag anerenv/polybar-process nil)))

(anerenv/start-panel)

#+end_src

*** Dunst

#+begin_src emacs-lisp
(defvar anerenv/dunst-process nil
  "Holds the process of the running Dunst instance, if any")

(defun anerenv/kill-dunst ()
  (interactive)
  (when anerenv/dunst-process
    (ignore-errors
      (kill-process anerenv/dunst-process)))
  (setq anerenv/dunst-process nil))

(defun anerenv/start-dunst ()
  (interactive)
  (progn
    (anerenv/kill-dunst)
    (setq anerenv/dunst-process
        (start-process-shell-command "dunst" "*dunst*" "dunst")))
    (set-process-query-on-exit-flag anerenv/dunst-process nil))

(anerenv/start-dunst)
#+end_src

*** Flameshot

#+begin_src emacs-lisp
(defvar anerenv/flameshot-process nil
  "Holds the process of the background flameshot service, if any")

(defun anerenv/kill-flameshot-process ()
  (interactive)
  (progn
    (when anerenv/flameshot-process
        (ignore-errors
        (kill-process anerenv/flameshot-process)))
    (setq anerenv/flameshot-process nil)))

(defun anerenv/start-flameshot-process ()
  (interactive)
  (progn
    (anerenv/kill-flameshot-process)
    (setq anerenv/flameshot-process
        (start-process-shell-command "flameshot" "*flameshot*" "flameshot"))
    (set-process-query-on-exit-flag anerenv/flameshot-process nil)))

(anerenv/start-flameshot-process)
#+end_src

*** Media keys

https://gist.github.com/ajyoon/5323b999a01dce8db2d4456da1740fe3

#+begin_src emacs-lisp
(dolist (k '(XF86AudioLowerVolume
             XF86AudioRaiseVolume
             XF86AudioPlay
             XF86AudioStop
             XF86AudioPrev
             XF86AudioNext))
  (push k exwm-input-prefix-keys))

(exwm-input-set-key
    (kbd "<XF86AudioRaiseVolume>")
    (lambda ()
        (interactive) (start-process-shell-command
        "pactl" nil "pactl set-sink-volume 0 +5%")))
(exwm-input-set-key
    (kbd "<XF86AudioLowerVolume>")
    (lambda ()
        (interactive) (start-process-shell-command
        "pactl" nil "pactl set-sink-volume 0 -5%")))

(exwm-input-set-key
    (kbd "<XF86AudioMute>")
        (lambda ()
            (interactive) (start-process-shell-command
            "pactl" nil "pactl set-sink-mute 0 toggle")))

(exwm-input-set-key
    (kbd "<XF86AudioPlay>")
    'desktop-environment-toggle-music)

(exwm-input-set-key
    (kbd "<XF86AudioNext>")
    'desktop-environment-music-next)

(exwm-input-set-key
    (kbd "<XF86AudioPrev>")
    'desktop-environment-music-previous)

(exwm-input-set-key
    (kbd "<XF86AudioStop>")
    'desktop-environment-music-stop)

(exwm-input-set-key
    (kbd "<XF86AudioPause>")
    'desktop-environment-toggle-music)

(exwm-input-set-key
    (kbd "<XF86MonBrightnessUp>")
        (lambda ()
            (interactive) (start-process-shell-command
            "xbacklight" nil "xbacklight -inc 5")))

(exwm-input-set-key
    (kbd "<XF86MonBrightnessDown>")
        (lambda ()
            (interactive) (start-process-shell-command
            "xbacklight" nil "xbacklight -dec 5")))

#+end_src

*** Input languages

#+begin_src emacs-lisp
(defun anerenv/enable-heb ()
  (interactive)
    (start-process-shell-command "heb" nil
        "setxkbmap -layout us,il && setxkbmap -option 'grp:alt_shift_toggle'"))
(anerenv/enable-heb)
#+end_src

*** Ending

End the execute only if EXWM block.
Close parens, then add to command switch.
#+begin_src emacs-lisp
))

(add-to-list 'command-switch-alist '("--start-exwm" . anerenv-load-exwm))
#+end_src

** Clean UI
Disabling the toolbar, the splash-screen, the menu-bar and the scroll-bar
#+begin_src emacs-lisp

(menu-bar-mode -1)   ; no menu bar
(when (display-graphic-p)
    (tool-bar-mode -1)   ; no tool bar with icons
    (scroll-bar-mode -1) ; no scroll bars
    (set-fringe-mode 0)
)
#+end_src

** Which-Key

#+begin_src emacs-lisp
(use-package which-key
  :config
    (which-key-mode)
)
#+end_src

** Background color

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(background-color . "LightYellow"))
#+end_src

** Easy Prompt

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Minibuff
#+begin_src emacs-lisp
(add-hook 'minibuffer-setup-hook
          (lambda ()
            (make-local-variable 'face-remapping-alist)
            (add-to-list 'face-remapping-alist '(default (:background "WhiteSmoke")))))
#+end_src

** Bell

#+begin_src emacs-lisp

(setq ring-bell-function (lambda () ()))

#+end_src
* Extras

#+begin_src emacs-lisp
(use-package load-dir
  :config (setq load-dirs (concat user-emacs-directory "extra/")))
#+end_src

